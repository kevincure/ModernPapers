<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Academic Paper Viewer</title>
    
    <!-- ------------------------------------------------------------------- -->
    <!-- MATHJAX CONFIGURATION -->
    <!-- ------------------------------------------------------------------- -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            },
            chtml: {
                displayAlign: 'center',
                displayIndent: '0'
            },
            svg: {
                displayAlign: 'center',
                displayIndent: '0'
            }
        };
    </script>
    <script id="MathJax-script" defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- Additional libs for index2 integration -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- ------------------------------------------------------------------- -->
    <!-- STYLES -->
    <!-- ------------------------------------------------------------------- -->
    <style>
        /* --------------------------------------------------------------- */
        /* CORE DESIGN SYSTEM */
        /* --------------------------------------------------------------- */
        :root {
            --font-serif: 'Georgia', 'Times New Roman', serif;
            --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            --bg-color: #fffff8;
            --text-color: #1a1a1a;
            --border-color: #d4d4d4;
            --link-color: #2563eb;
            --hover-bg: rgba(255, 229, 153, 0.2);
            --section-collapsed-bg: #f9f9f0;
            --popup-shadow: 0 10px 40px rgba(0,0,0,0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-serif);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.7;
            display: flex;
            min-height: 100vh;
        }

        a[href^="#"] {
            text-decoration: none;
        }

        p {
            margin: 0 0 1em;
        }

        /* --------------------------------------------------------------- */
        /* SIDEBAR NAVIGATION */
        /* --------------------------------------------------------------- */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 280px;
            height: 100vh;
            background: white;
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 20px;
            font-family: var(--font-sans);
        }

        .sidebar h3 {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #666;
            margin-bottom: 12px;
            margin-top: 20px;
        }

        .sidebar ul {
            list-style: none;
        }

        .sidebar li {
            margin-bottom: 8px;
        }

        .sidebar a {
            color: var(--text-color);
            text-decoration: none;
            font-size: 0.9rem;
            display: block;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .sidebar a:hover {
            background: var(--hover-bg);
        }

        .sidebar .subsection {
            padding-left: 16px;
            font-size: 0.85rem;
        }

        /* --------------------------------------------------------------- */
        /* MAIN CONTENT AREA */
        /* --------------------------------------------------------------- */
        .main-content {
            margin-left: 280px;
            flex: 1;
            font-size: 18px;
            max-width: 850px;
            padding: 60px 80px;
        }

        .paper-header {
            margin-bottom: 40px;
            padding-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
        }

        .paper-title {
            font-size: 2.2rem;
            line-height: 1.3;
            margin-bottom: 16px;
            font-weight: 400;
        }

        .paper-authors {
            font-size: 1.1rem;
            color: #555;
            margin-bottom: 8px;
        }

        .paper-metadata {
            font-family: var(--font-sans);
            font-size: 0.9rem;
            color: #666;
            margin-top: 12px;
            display: flex; 
            justify-content: space-between;
        }

        .abstract {
            background: #f9f9f0;
            padding: 20px;
            border-radius: 6px;
            margin: 24px 0;
            font-size: 0.95rem;
            line-height: 1.65;
        }

        .abstract-label {
            font-weight: 600;
            margin-bottom: 8px;
            font-style: italic;
        }

        /* --------------------------------------------------------------- */
        /* SECTIONS AND COLLAPSIBLE CONTENT */
        /* --------------------------------------------------------------- */
        .section {
            margin-bottom: 32px;
            position: relative;
        }

        .section-header {
            display: flex;
            align-items: center;
            margin-bottom: 22px;
            cursor: pointer;
            padding: 8px 0;
            user-select: none;
        }

        .section-header:hover {
            background: var(--hover-bg);
            margin-left: -8px;
            padding-left: 8px;
            border-radius: 4px;
        }

        .section-toggle {
            margin-right: 8px;
            font-family: var(--font-sans);
            font-size: 0.8rem;
            color: #999;
            transition: transform 0.2s;
        }

        .section-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .section h2 {
            font-size: 1.5rem;
            font-weight: 500;
        }

        .section h3 {
            font-size: 1.2rem;
            font-weight: 500;
            margin-top: 24px;
            margin-bottom: 12px;
        }

        .section-level-2 h2 { 
            font-size: 1.3rem; 
        }

        .section-level-3 h3 { 
            font-size: 1.1rem; 
        }

        .section-content {
            transition: all 0.3s ease;
            overflow: hidden;
            max-height: 100000px; /* Large number for animation */
        }

        .section-content.collapsed {
            max-height: 0;
            opacity: 0;
            padding: 0;
            margin: 0;
        }


        /* --------------------------------------------------------------- */
        /* ACADEMIC CONTENT ELEMENTS */
        /* --------------------------------------------------------------- */
        .theorem, .proof, .proposition, .lemma, .definition, .assumption, .remark, .corollary, .example {
            margin: 20px 0;
            padding: 16px;
            background: #f5f5f0;
            border-left: 3px solid #999;
            border-radius: 0 4px 4px 0;
        }

        .definition {
            border-left-color: #4a90e2;
        }

        .assumption {
            border-left-color: #e67e22;
        }

        .remark, .example {
            border-left-color: #95a5a6;
            background: #f8f8f5;
        }

        .theorem-header {
            font-weight: 600;
            margin-bottom: 8px;
            font-style: italic;
        }

        /* --------------------------------------------------------------- */
        /* MATHEMATICAL EQUATIONS */
        /* --------------------------------------------------------------- */
        .equation-display {
            display: flex;
            justify-content: center;
            margin: 0 0;
        }

        mjx-container[display="true"] {
            margin: 1em auto !important;
        }

        /* --------------------------------------------------------------- */
        /* FIGURES AND IMAGES */
        /* --------------------------------------------------------------- */
        .figure {
            overflow: hidden;
            position: relative;
            text-align: center;
        }

        .figure img {
            display: block; /* ensure caption starts on a new line */
            margin: 0 auto;
            max-width: 100%;
            max-height: 75vh; /* ≤ 75% of viewport height */
            transition: transform 0.2s ease;
            transform-origin: center center; /* default */
        }

        .figure:hover img {
            transform: scale(1.5);
            cursor: zoom-in;
        }

        .figure-caption {
            margin-top: 12px;
            font-size: 0.9rem;
            color: #666;
            font-style: italic;
            text-align: left;
            max-width: 90%;
            margin-left: auto;
            margin-right: auto;
        }

        /* --------------------------------------------------------------- */
        /* TABLES */
        /* --------------------------------------------------------------- */
        .table-container {
            margin: 24px 0;
            overflow-x: auto;
        }

        .table-container table {
            border-collapse: collapse;
            width: 100%;
            font-size: 0.9rem;
        }

        .table-container th,
        .table-container td {
            padding: 8px 12px;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        .table-container th {
            background: #f5f5f0;
            font-weight: 600;
        }

        .table-caption {
            margin-top: 8px;
            font-size: 0.9rem;
            color: #666;
            font-style: italic;
        }

        /* --------------------------------------------------------------- */
        /* LIST STYLES */
        /* --------------------------------------------------------------- */
        ul.bullet-list, ol.numbered-list {
            margin: 1em 0;
            padding-left: 2em;
        }

        ul.bullet-list li, ol.numbered-list li {
            margin-bottom: 0.5em;
        }

        /* --------------------------------------------------------------- */
        /* CITATIONS AND REFERENCES */
        /* --------------------------------------------------------------- */
        .citation, .xref {
            display: inline;
            text-decoration: none;
            color: inherit;
            cursor: pointer;
        }

        .citation {
            color: var(--link-color);
        }

        .citation:hover {
            background: var(--hover-bg);
            text-decoration: underline;
        }

        .xref {
            color: var(--link-color);
        }

        .xref:hover {
            text-decoration: underline;
        }

        .footnote-ref {
            vertical-align: super;
            font-size: 0.8em;
            color: var(--link-color);
            cursor: pointer;
            margin-left: 1px;
        }

        .footnote-ref:hover {
            text-decoration: underline;
        }

        /* --------------------------------------------------------------- */
        /* POPUP WINDOWS */
        /* --------------------------------------------------------------- */
        .popup {  
            display: none;
            position: absolute;
            padding: 12px 16px;             
            background: white;  
            border: 1px solid var(--border-color);  
            border-radius: 6px;  
            box-shadow: var(--popup-shadow);  
            z-index: 1000;
            max-width: 100%;
            font-size: 0.9rem;
        } 
        
        #popup .popup-content { word-wrap: break-word; overflow-wrap: anywhere; }
        
        .popup.visible {
            display: block;
        }

        .citation-popup {
            font-family: var(--font-sans);
        }

        .citation-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .citation-authors {
            color: #666;
            font-size: 0.85rem;
            margin-bottom: 8px;
        }

        .citation-link {
            color: var(--link-color);
            text-decoration: none;
            font-size: 0.85rem;
        }

        /* --------------------------------------------------------------- */
        /* BUTTONS AND CONTROLS */
        /* --------------------------------------------------------------- */
        .talk-button {
            width: 100%;
            padding: 10px;
            background: #333;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
            font-family: var(--font-sans);
            margin-bottom: 12px;
        }

        .talk-button:hover {
            background: #111;
        }

        .plaintext-button {
            width: 100%;
            padding: 8px 12px;
            margin-bottom: 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: #f9f9f0;
            font-family: var(--font-sans);
            font-size: 0.9rem;
            cursor: pointer;
        }

        .plaintext-button:hover {
            background: #ece8d3;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: #999;
            padding: 4px 8px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: #f0f0f0;
            color: #333;
        }

        .send-btn {
            padding: 10px 20px;
            background: #333;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        /* --------------------------------------------------------------- */
        /* MOBILE RESPONSIVENESS */
        /* --------------------------------------------------------------- */
        .mobile-only {
            display: none;
        }

        @media (max-width: 1024px) {
            .sidebar {
                display: none !important;
            }
            
            .mobile-only {
                display: block;
            }
            
            .talk-button.mobile-only,
            .plaintext-button.mobile-only {
                position: fixed;
                top: 8px;
                width: calc(50% - 12px);
                margin: 0;
                padding: 8px 12px;
                border: 1px solid var(--border-color);
                border-radius: 4px;
                background: #f9f9f0;
                font-family: var(--font-sans);
                font-size: 0.9rem;
                cursor: pointer;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                z-index: 1001;
                color: var(--text-color);
            }
            
            .talk-button.mobile-only { 
                left: 8px; 
            }

            .plaintext-button.mobile-only { 
                right: 8px; 
            }
            
            .talk-button.mobile-only:hover,
            .plaintext-button.mobile-only:hover {
                background: #ece8d3;
            }
            
            .main-content {
                margin-left: 0;
                padding: 65px 20px 40px 20px;
                max-width: 100%;
            }
        }

        /* --------------------------------------------------------------- */
        /* LOADING STATE */
        /* --------------------------------------------------------------- */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 248, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .loading-spinner {
            border: 2px solid #ccc;
            border-top: 2px solid #333;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-note {
            margin-top: 12px;
            font-family: var(--font-sans);
            font-size: 0.9rem;
            color: #666;
            text-align: center;
        }

        /* --------------------------------------------------------------- */
        /* MODAL WINDOWS */
        /* --------------------------------------------------------------- */
        .api-key-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: var(--popup-shadow);
            padding: 32px;
            width: 400px;
            max-width: 90vw;
            z-index: 3001;
            display: none;
        }

        .api-key-modal.visible {
            display: block;
        }

        .api-key-modal h3 {
            font-size: 1.2rem;
            margin-bottom: 16px;
            font-family: var(--font-sans);
        }

        .api-key-modal p {
            color: #666;
            margin-bottom: 20px;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .api-key-modal input {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.9rem;
            margin-bottom: 16px;
            font-family: monospace;
        }

        .api-key-modal button {
            padding: 8px 24px;
            background: #333;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .api-key-modal button:hover {
            background: #111;
        }

        #apiKeyModal {
            z-index: 4000;  /* anything above 3001 */
        }

        /* --------------------------------------------------------------- */
        /* CHAT INTERFACE */
        /* --------------------------------------------------------------- */
        .chat-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 2000;
        }

        .chat-modal-overlay.visible {
            display: block;
        }

        .chat-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 700px;
            height: 80vh;
            background: white;
            border-radius: 12px;
            box-shadow: var(--popup-shadow);
            display: flex;
            flex-direction: column;
            z-index: 2001;
        }

        .chat-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: var(--font-sans);
        }

        .chat-controls {
            display: flex;
            gap: 8px;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            font-family: var(--font-sans);
        }

        .chat-message {
            margin-bottom: 16px;
            padding: 12px;
            border-radius: 8px;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .chat-message.user {
            background: #e3f2fd;
            margin-left: 20%;
        }

        .chat-message.ai {
            background: #f5f5f5;
            margin-right: 20%;
        }

        .chat-input-container {
            padding: 16px;
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 8px;
        }

        .chat-input {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.9rem;
            font-family: var(--font-sans);
        }

        .plaintext-summary {
            margin: 24px 0;
        }
        /* Buttons */
        .btn { background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); color:#fff; border:none; padding:8px 14px; border-radius:8px; cursor:pointer; font-size:0.95rem; }
        .btn.secondary { background:#6c757d; }
        .btn:disabled { opacity:.5; cursor:not-allowed; }
        /* Figure Extraction Modal styling (inspired by ExtractFigures) */
        .fx-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 3500; display: none; align-items: center; justify-content: center; }
        .fx-modal { background: #fff; width: min(1200px, 95vw); max-height: 92vh; border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); display:flex; flex-direction: column; overflow: hidden; }
        .fx-header { display:flex; align-items:center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid #e0e0e0; }
        .fx-header h2 { margin: 0; color: #1e3c72; font-size: 1.2rem; font-family: var(--font-sans); }
        .fx-actions { display:flex; gap: 8px; }
        .fx-body { padding: 16px 20px; overflow: auto; }
        .settings { background: #f8f9fa; border-radius: 10px; padding: 12px; margin: 10px 0 12px; }
        .settings-title { font-weight: 600; margin-bottom: 8px; font-family: var(--font-sans); }
        .setting-row { display:flex; align-items:center; gap: 8px; margin-bottom: 8px; }
        .setting-label { flex:1; color:#555; font-family: var(--font-sans); }
        .setting-input { width: 100px; padding: 5px 10px; border:1px solid #ddd; border-radius:6px; }
        .progress { display: none; margin-top: 10px; background: #f0f0f0; border-radius: 10px; overflow: hidden; height: 8px; }
        .progress-bar { background: linear-gradient(90deg, #1e3c72 0%, #2a5298 100%); height: 100%; width: 0%; transition: width 0.3s ease; }
        .status { margin-top: 10px; color: #666; font-family: var(--font-sans); }
        .error { display:none; color: #e74c3c; margin-top: 10px; padding: 10px; background:#ffe6e6; border-radius:8px; font-family: var(--font-sans); }
        .results { display:none; margin-top: 14px; }
        .results-header { display:flex; justify-content: space-between; align-items:center; margin-bottom: 10px; gap: 8px; flex-wrap: wrap; }
        .results-title { font-size: 1.1rem; font-weight: 600; }
        .action-buttons { display:flex; gap: 8px; flex-wrap: wrap; }
        .image-grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 12px; }
        .image-item { background:#fff; border-radius:10px; padding: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.08); position:relative; }
        .image-item.selected { box-shadow: 0 0 0 3px rgba(30,60,114,0.5); }
        .image-checkbox { position:absolute; top:8px; right:8px; width:20px; height:20px; cursor:pointer; }
        .image-preview { width:100%; height:200px; object-fit:contain; background:#f8f8f8; border-radius:5px; margin-bottom: 8px; cursor: pointer; }
        .figure-title { font-weight: 600; color: #1e3c72; margin-bottom: 6px; font-family: var(--font-sans); }
        .image-info { font-size: 0.9rem; color: #666; margin-bottom: 6px; font-family: var(--font-sans); }
        .filename-input { width:100%; padding:6px; border:1px solid #ddd; border-radius:6px; margin-top:6px; font-size:0.9rem; font-family: var(--font-sans); }
    </style>
</head>

<body>
    <!-- ------------------------------------------------------------------- -->
    <!-- MOBILE NAVIGATION BUTTONS -->
    <!-- ------------------------------------------------------------------- -->
    <button class="talk-button mobile-only" id="talkButtonMobile">AI Chat</button>
    <button class="plaintext-button mobile-only" id="plaintextButtonMobile" onclick="showPlaintextModal()">Layman Summary</button>

    <!-- ------------------------------------------------------------------- -->
    <!-- SIDEBAR NAVIGATION -->
    <!-- ------------------------------------------------------------------- -->
    <div class="sidebar" id="sidebar" style="display:none;">
        <button class="talk-button" id="talkButton">AI Chat</button>
        <button class="plaintext-button" id="plaintextButton" onclick="showPlaintextModal()">Layman Summary</button>
        <button class="plaintext-button" id="downloadXmlBtn" style="display: none; background: #e8f4f8; margin-bottom: 12px;">Download XML + Images</button>
        
        <h3 id="toc-title">Contents</h3>
        <ul id="tocList"></ul>
    </div>

    <!-- ------------------------------------------------------------------- -->
    <!-- MAIN CONTENT AREA -->
    <!-- ------------------------------------------------------------------- -->
    <main class="main-content" id="mainContent">
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-spinner"></div>
            <div class="loading-note">Processing | can take a few minutes for long papers.</div>
        </div>
    </main>

    <!-- ------------------------------------------------------------------- -->
    <!-- POPUP CONTAINER -->
    <!-- ------------------------------------------------------------------- -->
    <div class="popup" id="popup">
        <div class="popup-content" id="popupContent"></div>
    </div>

    <!-- ------------------------------------------------------------------- -->
    <!-- MODAL DIALOGS -->
    <!-- ------------------------------------------------------------------- -->
    
    <!-- API Key Modal -->
    <div class="api-key-modal" id="apiKeyModal">
        <h3>Gemini API Key Required</h3>
        <p>Please enter your Gemini API key to use the Q&A feature. Your key will only be stored for this session.</p>
        <p style="font-size: 0.85rem;">Get a free key at: <a href="https://aistudio.google.com/app/apikey" target="_blank">aistudio.google.com</a></p>
        <input type="password" id="apiKeyInput" placeholder="Enter your Gemini API key">
        <button id="apiKeySubmit">Continue</button>
    </div>

    <!-- Upload Modal -->
    <div class="api-key-modal" id="uploadModal" style="display: none;">
        <h3>Upload Paper</h3>
        <p>Drop a PDF/PPTX or LaTeX + BIB files. We'll extract/confirm figures, then convert to structured XML.</p>
        <input type="file" id="fileInput" accept=".pdf,.pptx,.tex,.bib" multiple style="margin-bottom: 12px;">
        <div id="uploadStatus" style="color: #666; font-size: 0.9rem; margin-bottom: 12px;"></div>
        <button id="convertBtn" style="display: none;">Convert Paper</button>
    </div>

    <!-- Chat Modal -->
    <div class="chat-modal-overlay" id="chatOverlay">
        <div class="chat-modal">
            <div class="chat-header">
                <h3>Ask AI about this paper</h3>
                <div class="chat-controls">
                    <button class="close-btn" id="closeChat">&times;</button>
                </div>
            </div>
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input-container">
                <input type="text" class="chat-input" id="chatInput" placeholder="Ask any question about this paper...">
                <button class="send-btn" id="sendBtn">Ask</button>
            </div>
        </div>
    </div>

    <!-- Figure Review Modal (full-screen) -->
    <div class="fx-overlay" id="fxOverlay" style="display:none;">
      <div class="fx-modal">
        <div class="fx-header">
          <h2>Review and Select Figures</h2>
          <div class="fx-actions">
            <button class="btn secondary" id="fx-cancel">Cancel</button>
            <button class="btn" id="fx-done">Prepare XML</button>
          </div>
        </div>
        <div class="fx-body">
          <div class="progress" id="fx-progress" style="display:none;">
            <div class="progress-bar" id="fx-progressBar"></div>
          </div>
          <div class="status" id="fx-status"></div>
          <div class="error" id="fx-error" style="display:none;"></div>
          <div class="results" id="fx-results" style="display:none;">
            <div class="results-header">
              <div class="results-title" id="fx-resultsTitle">Extracted Figures</div>
              <div class="action-buttons">
                <button class="btn secondary" id="fx-selectAll">Select All</button>
                <button class="btn secondary" id="fx-selectNone">Deselect All</button>
                <button class="btn" id="fx-combine" disabled title="Select two figures from the same page">Combine Selected</button>
              </div>
            </div>
            <div class="image-grid" id="fx-imageGrid"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- ------------------------------------------------------------------- -->
    <!-- JAVASCRIPT APPLICATION -->
    <!-- ------------------------------------------------------------------- -->
    <script>
        // --------------------------------------------------------------- 
        // GLOBAL STATE MANAGEMENT
        // ---------------------------------------------------------------
        let expandedSections = new Set();
        let sessionApiKey = '';
        let footnoteCounter = 0;
        let currentPaperXML = null;
        let currentPaperText = '';
        let chatHistory = [];
        let usedUploadThisSession = false;

        // --------------------------------------------------------------- 
        // DOM ELEMENT REFERENCES
        // ---------------------------------------------------------------
        const mainContent = document.getElementById('mainContent');
        const tocList = document.getElementById('tocList');
        const popup = document.getElementById('popup');
        const popupContent = document.getElementById('popupContent');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const apiKeyModal = document.getElementById('apiKeyModal');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const apiKeySubmit = document.getElementById('apiKeySubmit');
        const talkButton = document.getElementById('talkButton');
        const chatOverlay = document.getElementById('chatOverlay');
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendBtn = document.getElementById('sendBtn');
        const closeChat = document.getElementById('closeChat');

        // --------------------------------------------------------------- 
        // INTEGRATED FIGURE EXTRACTION (from ExtractFigures)
        // ---------------------------------------------------------------
        let extractedFigures = [];
        let figureBlobMap = {};
        const fxOverlay = document.getElementById('fxOverlay');
        const fx = {
            status: document.getElementById('fx-status'),
            progress: document.getElementById('fx-progress'),
            progressBar: document.getElementById('fx-progressBar'),
            error: document.getElementById('fx-error'),
            results: document.getElementById('fx-results'),
            resultsTitle: document.getElementById('fx-resultsTitle'),
            imageGrid: document.getElementById('fx-imageGrid'),
            selectAll: document.getElementById('fx-selectAll'),
            selectNone: document.getElementById('fx-selectNone'),
            combine: document.getElementById('fx-combine'),
        };

        // pdf.js dynamic loader and worker configuration
        async function ensurePdfjsLibLoaded() {
            if (window.pdfjsLib) return;
            await new Promise((resolve, reject) => {
                const primary = document.createElement('script');
                primary.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/pdf.min.js';
                primary.onload = resolve;
                primary.onerror = () => {
                    const fallback = document.createElement('script');
                    fallback.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
                    fallback.onload = resolve;
                    fallback.onerror = reject;
                    document.head.appendChild(fallback);
                };
                document.head.appendChild(primary);
            });
        }
        function configurePdfjsWorker() {
            if (!window.pdfjsLib) return;
            const version = (pdfjsLib.version || '').toString();
            const isV4 = version.startsWith('4.');
            const workerSrc = isV4
                ? 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/pdf.worker.min.js'
                : 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            pdfjsLib.GlobalWorkerOptions.workerSrc = workerSrc;
        }

        // Helpers
        function baseLabelFromTitle(title='') {
          const m = /\b(?:Fig(?:ure)?\.?)\s*([A-Za-z]?\d+[A-Za-z0-9]*)/i.exec(title);
          return m ? m[1].toUpperCase() : '';
        }
        function uniquifyFilename(name) {
          const used = new Set(extractedFigures.map(f => (f.filename || '').toLowerCase()));
          let stem = name.replace(/\.png$/i,''); let n = 1; let cand = stem + '.png';
          while (used.has(cand.toLowerCase())) cand = `${stem}-${++n}.png`;
          return cand;
        }
        function suggestFilename(title, pageNum) {
          const label = baseLabelFromTitle(title);
          return uniquifyFilename(`${label ? `fig-${label}` : `fig-${pageNum}`}.png`);
        }
        function updateFxProgress(pct){ fx.progress.style.display='block'; fx.progressBar.style.width = `${pct}%`; }
        function fxStatus(msg){ fx.status.textContent = msg; }
        function fxError(msg){ fx.error.textContent = msg; fx.error.style.display='block'; setTimeout(()=>fx.error.style.display='none', 5000); }
        function resetFigureUI(){ extractedFigures = []; fx.imageGrid.innerHTML=''; fx.results.style.display='none'; fx.progress.style.display='none'; fx.status.textContent=''; }

        // Matrix + geometry helpers from ExtractFigures
        function multiplyMatrices(m1, m2) {
            return [
                m1[0] * m2[0] + m1[2] * m2[1],
                m1[1] * m2[0] + m1[3] * m2[1],
                m1[0] * m2[2] + m1[2] * m2[3],
                m1[1] * m2[2] + m1[3] * m2[3],
                m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
                m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
            ];
        }
        function applyToPoint(m, x, y) { return { x: m[0]*x + m[2]*y + m[4], y: m[1]*x + m[3]*y + m[5] }; }
        function computeTextBoxesInRenderSpace(textContent, renderViewport) {
            const boxes = [];
            for (const item of textContent.items) {
                if (!item || !item.transform) continue;
                const M = multiplyMatrices(renderViewport.transform, item.transform);
                const a = applyToPoint(M, 0, 0);
                const b = applyToPoint(M, item.width || 0, 0);
                const c = applyToPoint(M, 0, 1);
                const minX = Math.min(a.x, b.x, c.x);
                const minY = Math.min(a.y, b.y, c.y);
                const maxX = Math.max(a.x, b.x, c.x);
                const maxY = Math.max(a.y, b.y, c.y);
                const w = Math.max(1, Math.round(maxX - minX));
                const h = Math.max(1, Math.round(maxY - minY));
                boxes.push({ x: Math.round(minX), y: Math.round(minY), w, h });
            }
            return boxes;
        }
        function boxesOverlap(a, b) {
            const ix = Math.max(0, Math.min(a.x + a.w, b.x + b.w) - Math.max(a.x, b.x));
            const iy = Math.max(0, Math.min(a.y + a.h, b.y + b.h) - Math.max(a.y, b.y));
            return ix > 0 && iy > 0 ? ix * iy : 0;
        }
        function horizontalOverlapRatio(a, b) {
            const ix = Math.max(0, Math.min(a.x + a.w, b.x + b.w) - Math.max(a.x, b.x));
            return ix / Math.min(a.w, b.w);
        }
        function verticalOverlapRatio(a, b) {
            const iy = Math.max(0, Math.min(a.y + a.h, b.y + b.h) - Math.max(a.y, b.y));
            return iy / Math.min(a.h, b.h);
        }
        function rectBetween(a, b) {
            if (a.x + a.w <= b.x || b.x + b.w <= a.x) {
                const left = a.x + a.w <= b.x ? a : b;
                const right = left === a ? b : a;
                const y = Math.max(a.y, b.y);
                const y2 = Math.min(a.y + a.h, b.y + b.h);
                return { x: left.x + left.w, y, w: Math.max(0, right.x - (left.x + left.w)), h: Math.max(0, y2 - y) };
            }
            if (a.y + a.h <= b.y || b.y + b.h <= a.y) {
                const top = a.y + a.h <= b.y ? a : b;
                const bottom = top === a ? b : a;
                const x = Math.max(a.x, b.x);
                const x2 = Math.min(a.x + a.w, b.x + b.w);
                return { x, y: top.y + top.h, w: Math.max(0, x2 - x), h: Math.max(0, bottom.y - (top.y + top.h)) };
            }
            return { x: 0, y: 0, w: 0, h: 0 };
        }
        function textCoverage(rect, textBoxes) {
            if (!rect || rect.w <= 0 || rect.h <= 0) return 0;
            const area = rect.w * rect.h;
            let covered = 0;
            for (const t of textBoxes) {
                const ix = Math.max(0, Math.min(rect.x + rect.w, t.x + t.w) - Math.max(rect.x, t.x));
                const iy = Math.max(0, Math.min(rect.y + rect.h, t.y + t.h) - Math.max(rect.y, t.y));
                covered += ix * iy;
            }
            return covered / Math.max(1, area);
        }
        function mergeImageBoxes(boxes, textBoxes = []) {
            const merged = boxes.slice();
            let changed = true;
            while (changed) {
                changed = false;
                for (let i = 0; i < merged.length; i++) {
                    for (let j = i + 1; j < merged.length; j++) {
                        const a = merged[i], b = merged[j];
                        const vOverlap = verticalOverlapRatio(a, b);
                        const hOverlap = horizontalOverlapRatio(a, b);
                        const gapX = Math.max(0, Math.max(a.x, b.x) - Math.min(a.x + a.w, b.x + b.w));
                        const gapY = Math.max(0, Math.max(a.y, b.y) - Math.min(a.y + a.h, b.y + b.h));
                        const smallDim = Math.min(Math.min(a.w, a.h), Math.min(b.w, b.h));
                        const nearHoriz = gapX < Math.max(12, smallDim * 0.12);
                        const nearVert  = gapY < Math.max(12, smallDim * 0.12);
                        const interArea = boxesOverlap(a, b);
                        const smallerArea = Math.min(a.w * a.h, b.w * b.h);
                        const significantIntersection = interArea / Math.max(1, smallerArea) > 0.06;
                        const gapRect = rectBetween(a, b);
                        const hasText = textCoverage(gapRect, textBoxes) > 0.15;
                        const horizontallyAligned = vOverlap > 0.35 && (hOverlap > 0.1 || nearHoriz);
                        const verticallyAligned   = hOverlap > 0.35 && (vOverlap > 0.1 || nearVert);
                        if ((horizontallyAligned || verticallyAligned || significantIntersection) && !hasText) {
                            const nx = Math.min(a.x, b.x), ny = Math.min(a.y, b.y);
                            const nx2 = Math.max(a.x + a.w, b.x + b.w);
                            const ny2 = Math.max(a.y + a.h, b.y + b.h);
                            merged[i] = { x: nx, y: ny, w: nx2 - nx, h: ny2 - ny };
                            merged.splice(j, 1);
                            changed = true;
                            break;
                        }
                    }
                    if (changed) break;
                }
            }
            return merged.map(b => {
                const padX = Math.round(b.w * 0.01) + 2;
                const padY = Math.round(b.h * 0.005) + 1;
                return { x: Math.max(0, b.x - padX), y: Math.max(0, b.y - padY), w: b.w + padX * 2, h: b.h + padY * 2 };
            });
        }
        function shrinkCropToAvoidText(crop, textBoxes) {
            const { x, y, w, h } = crop;
            let top = y, bottom = y + h; const left = x, right = x + w;
            const horizOverlap = (bx) => Math.max(0, Math.min(right, bx.x + bx.w) - Math.max(left, bx.x)) / Math.max(1, w);
            const topBandY = y + Math.round(h * 0.10);
            const bottomBandY = y + Math.round(h * 0.90);
            let topMax = top, bottomMin = bottom; let topOverlapWidth = 0, topBoxCount = 0, bottomOverlapWidth = 0, bottomBoxCount = 0;
            for (const b of textBoxes) {
                const overlap = horizOverlap(b);
                if (overlap < 0.8) continue;
                const bTop = b.y, bBottom = b.y + b.h;
                if (bBottom <= topBandY) { topMax = Math.max(topMax, bBottom); topOverlapWidth += (Math.min(right, b.x + b.w) - Math.max(left, b.x)); topBoxCount++; }
                if (bTop >= bottomBandY) { bottomMin = Math.min(bottomMin, bTop); bottomOverlapWidth += (Math.min(right, b.x + b.w) - Math.max(left, b.x)); bottomBoxCount++; }
            }
            const maxTrim = Math.round(h * 0.10);
            const margin = Math.max(1, Math.round(Math.min(w, h) * 0.005));
            if (topBoxCount >= 2 || topOverlapWidth > w * 0.6) { const proposed = Math.min(maxTrim, Math.max(0, (topMax + margin) - top)); top += proposed; }
            if (bottomBoxCount >= 2 || bottomOverlapWidth > w * 0.6) { const proposed = Math.min(maxTrim, Math.max(0, bottom - (bottomMin - margin))); bottom -= proposed; }
            if (bottom <= top + 1) return { x: left, y: top, w: Math.max(1, right - left), h: 1 };
            return { x: left, y: top, w: right - left, h: bottom - top };
        }

        function displayFxResults() {
            if (extractedFigures.length === 0) { fxStatus('No figures found that meet the specified criteria.'); return; }
            fx.resultsTitle.textContent = `Extracted Figures (${extractedFigures.length})`;
            fx.results.style.display = 'block';
            fx.imageGrid.innerHTML = '';
            extractedFigures.forEach((fig, index) => {
                const item = document.createElement('div');
                item.className = 'image-item' + (fig.selected ? ' selected' : '');
                item.dataset.index = index;
                item.innerHTML = `
                  <input type="checkbox" class="image-checkbox" ${fig.selected ? 'checked' : ''}>
                  <div class="figure-title">${fig.title || 'Figure'}</div>
                  <img src="${fig.url}" alt="Figure ${index + 1}" class="image-preview">
                  <div class="image-info">${fig.page ? `Page: ${fig.page} • ` : ''}${fig.width}×${fig.height}px</div>
                  <input class="filename-input" value="${fig.filename}">
                  ${fig.caption ? `<div class="caption">${fig.caption}</div>` : ''}
                `;
                fx.imageGrid.appendChild(item);
            });
            updateCombineButtonState();
        }

        function attachFxListeners() {
            if (!fx._listenersAttached) {
                fx.selectAll.addEventListener('click', () => toggleFxSelection(true));
                fx.selectNone.addEventListener('click', () => toggleFxSelection(false));
                fx.combine.addEventListener('click', () => smartCombineSelected());
                document.getElementById('fx-cancel').addEventListener('click', () => { fxOverlay.style.display = 'none'; });
                document.getElementById('fx-done').addEventListener('click', () => {
                    fxOverlay.style.display = 'none';
                    const btn = document.getElementById('convertBtn');
                    if (btn && !btn.disabled) btn.click();
                });
                fx.imageGrid.addEventListener('click', (e) => {
                    const item = e.target.closest('.image-item');
                    if (!item) return;
                    if (e.target.matches('.filename-input')) { e.stopPropagation(); return; }
                    const index = parseInt(item.dataset.index, 10);
                    const checkbox = item.querySelector('.image-checkbox');
                    if (e.target !== checkbox) { checkbox.checked = !checkbox.checked; }
                    if (extractedFigures[index]) {
                        extractedFigures[index].selected = checkbox.checked;
                        item.classList.toggle('selected', checkbox.checked);
                        updateCombineButtonState();
                    }
                });
                fx.imageGrid.addEventListener('input', (e) => {
                    if (!e.target.matches('.filename-input')) return;
                    const idx = parseInt(e.target.closest('.image-item').dataset.index, 10);
                    extractedFigures[idx].filename = e.target.value.trim();
                });
                fx.imageGrid.addEventListener('blur', (e) => {
                    if (!e.target.matches('.filename-input')) return;
                    let v = e.target.value.trim();
                    if (!/\.png$/i.test(v)) v += '.png';
                    e.target.value = v;
                    const idx = parseInt(e.target.closest('.image-item').dataset.index, 10);
                    extractedFigures[idx].filename = v;
                }, true);
                fx._listenersAttached = true;
            }
        }
        function updateCombineButtonState() {
            const sel = extractedFigures.filter(f => f.selected);
            const ok = sel.length === 2 && sel[0].page === sel[1].page;
            if (fx.combine) fx.combine.disabled = !ok;
            if (fx.combine) fx.combine.title = ok ? 'Combine the two selected figures' : 'Select two figures from the same page';
        }
        function toggleFxSelection(selected) {
            document.querySelectorAll('#fx-imageGrid .image-item').forEach(item => {
                const index = parseInt(item.dataset.index, 10);
                if (extractedFigures[index]) {
                    extractedFigures[index].selected = selected;
                    item.classList.toggle('selected', selected);
                    item.querySelector('.image-checkbox').checked = selected;
                }
            });
        }

        // combine two selected (auto orientation, only same-page)
        function loadImage(url){ return new Promise(r=>{ const i=new Image(); i.onload=()=>r(i); i.src=url; }); }
        async function smartCombineSelected() {
          const selIdxs = [];
          extractedFigures.forEach((f,i)=>f.selected && selIdxs.push(i));
          if (selIdxs.length !== 2) { fxError('Select exactly two figures.'); return; }
          const [i1,i2] = selIdxs;
          const A = extractedFigures[i1], B = extractedFigures[i2];
          if (A.page !== B.page) { fxError('Please select two figures from the same page.'); return; }
          const [imgA, imgB] = await Promise.all([loadImage(A.url), loadImage(B.url)]);
          // Heuristic: decide orientation based on bbox positions if available
          let orientation = 'horizontal';
          if (A.bbox && B.bbox) {
            const acx = A.bbox.x + A.bbox.w/2, acy = A.bbox.y + A.bbox.h/2;
            const bcx = B.bbox.x + B.bbox.w/2, bcy = B.bbox.y + B.bbox.h/2;
            const dx = Math.abs(acx - bcx); const dy = Math.abs(acy - bcy);
            // If vertical centers close in Y, place side-by-side; otherwise stack vertically
            orientation = dy < Math.min(A.bbox.h, B.bbox.h) * 0.6 ? 'horizontal' : 'vertical';
          } else {
            // Fallback: choose by aspect
            orientation = (imgA.width + imgB.width) / Math.max(imgA.height, imgB.height) <= 2.2 ? 'horizontal' : 'vertical';
          }
          const cw = orientation === 'horizontal' ? (imgA.width + imgB.width) : Math.max(imgA.width, imgB.width);
          const ch = orientation === 'horizontal' ? Math.max(imgA.height, imgB.height) : (imgA.height + imgB.height);
          const combo = document.createElement('canvas'); combo.width = cw; combo.height = ch;
          const ctx = combo.getContext('2d');
          ctx.drawImage(imgA, 0, 0);
          if (orientation === 'horizontal') ctx.drawImage(imgB, imgA.width, 0); else ctx.drawImage(imgB, 0, imgA.height);
          const MAX_DIM = 1024;
          let out = combo;
          if (cw > MAX_DIM || ch > MAX_DIM) {
            const s = Math.min(MAX_DIM/cw, MAX_DIM/ch);
            out = document.createElement('canvas'); out.width = Math.round(cw*s); out.height = Math.round(ch*s);
            out.getContext('2d').drawImage(combo, 0, 0, out.width, out.height);
          }
          const blob = await new Promise(res => out.toBlob(res, 'image/png'));
          const aLab = baseLabelFromTitle(A.title) || (A.filename||'').replace(/\.png$/i,'').replace(/^fig-/i,'') || `p${A.page}`;
          const bLab = baseLabelFromTitle(B.title) || (B.filename||'').replace(/\.png$/i,'').replace(/^fig-/i,'') || `p${B.page}`;
          const newName = uniquifyFilename(`fig-${aLab}_${bLab}.png`);
          // Remove originals, keep only combined
          const hi = Math.max(i1,i2), lo = Math.min(i1,i2);
          extractedFigures.splice(hi,1); extractedFigures.splice(lo,1);
          const combined = {
            page: A.page, width: out.width, height: out.height,
            blob, url: URL.createObjectURL(blob),
            filename: newName,
            title: `Combined: ${A.title || A.filename} + ${B.title || B.filename}`,
            caption: '', selected: true
          };
          extractedFigures.push(combined);
          displayFxResults();
        }

        async function handlePPTXForFX(file) {
            try {
                fxOverlay.style.display = 'flex';
                resetFigureUI();
                fxStatus('Processing PowerPoint file...');
                const zip = await JSZip.loadAsync(file);
                const mediaFolder = zip.folder('ppt/media');
                if (!mediaFolder) throw new Error('No media folder found.');
                const imagePromises = [];
                mediaFolder.forEach((relativePath, file) => {
                    if (/\.(png|jpe?g|gif|bmp)$/i.test(relativePath)) {
                        imagePromises.push(file.async('blob').then(blob => ({ blob, path: relativePath })));
                    }
                });
                const imageFiles = await Promise.all(imagePromises);
                fxStatus(`Found ${imageFiles.length} images. Extracting...`);
                for (let i = 0; i < imageFiles.length; i++) {
                    const imgFile = imageFiles[i];
                    const url = URL.createObjectURL(imgFile.blob);
                    const imgTag = await new Promise(resolve => { const image = new Image(); image.onload = () => resolve(image); image.src = url; });
                    extractedFigures.push({
                        page: `Slide ${i + 1}`, width: imgTag.width, height: imgTag.height, blob: imgFile.blob, url,
                        filename: suggestFilename('', extractedFigures.length + 1), title: `Image from ${imgFile.path}`,
                        caption: `Original dimensions: ${imgTag.width}×${imgTag.height}px`, selected: true
                    });
                }
                updateFxProgress(100);
                attachFxListeners();
                displayFxResults();
                // If nothing was extracted, auto-close and convert
                if (extractedFigures.length === 0) {
                    fxOverlay.style.display = 'none';
                    const btn = document.getElementById('convertBtn');
                    if (btn && !btn.disabled) btn.click();
                }
            } catch (err) {
                fxError(`Error processing PPTX file: ${err.message}`);
            } finally {
                setTimeout(()=> fx.progress.style.display='none', 500);
            }
        }

        async function handlePDFForFX(file) {
            try {
                fxOverlay.style.display = 'flex';
                resetFigureUI();
                await ensurePdfjsLibLoaded();
                configurePdfjsWorker();
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const totalPages = pdf.numPages;
                fxStatus(`Analyzing ${totalPages} pages...`);
                const minSizePercent = 0.02; // 2% of page area
                const skipTables = true;
                for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                    updateFxProgress(((pageNum - 1) / totalPages) * 100);
                    fxStatus(`Processing page ${pageNum} of ${totalPages}...`);
                    const page = await pdf.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 1.0 });
                    const pageArea = viewport.width * viewport.height;
                    const minPixelArea = pageArea * minSizePercent;
                const textContent = await page.getTextContent();
                const operatorList = await page.getOperatorList();
                const identity = [1,0,0,1,0,0];
                let currentTransform = identity.slice();
                const transformStack = [];
                const imagePaints = [];
                const formPaints = [];
                for (let i = 0; i < operatorList.fnArray.length; i++) {
                    const fn = operatorList.fnArray[i];
                    const args = operatorList.argsArray[i];
                    if (fn === pdfjsLib.OPS.save) {
                        transformStack.push(currentTransform.slice());
                    } else if (fn === pdfjsLib.OPS.restore) {
                        currentTransform = transformStack.pop() || identity.slice();
                    } else if (fn === pdfjsLib.OPS.transform) {
                        currentTransform = multiplyMatrices(currentTransform, args);
                    } else if (fn === pdfjsLib.OPS.paintFormXObjectBegin) {
                        const formM = (args && Array.isArray(args[0])) ? args[0] : identity;
                        const bbox = (args && Array.isArray(args[1]) && args[1].length >= 4) ? args[1] : null;
                        transformStack.push(currentTransform.slice());
                        currentTransform = multiplyMatrices(currentTransform, formM);
                        // Capture a candidate vector-figure rectangle for this Form XObject
                        // Use provided bbox if available; otherwise approximate unit square
                        formPaints.push({
                            bbox: bbox ? [bbox[0], bbox[1], bbox[2], bbox[3]] : [0,0,1,1],
                            hasBBox: !!bbox,
                            ctm: currentTransform.slice()
                        });
                    } else if (pdfjsLib.OPS.paintFormXObjectEnd && fn === pdfjsLib.OPS.paintFormXObjectEnd) {
                        currentTransform = transformStack.pop() || identity.slice();
                    } else if (fn === pdfjsLib.OPS.paintImageXObject) {
                        imagePaints.push({ arg: args[0], inline: false, ctm: currentTransform.slice() });
                    } else if (pdfjsLib.OPS.paintInlineImageXObject && fn === pdfjsLib.OPS.paintInlineImageXObject) {
                        imagePaints.push({ arg: null, inline: true, ctm: currentTransform.slice() });
                    } else if (pdfjsLib.OPS.paintInlineImageXObjectGroup && fn === pdfjsLib.OPS.paintInlineImageXObjectGroup) {
                        imagePaints.push({ arg: null, inline: true, ctm: currentTransform.slice() });
                    }
                }
                    const renderScale = 3.0;
                    const baseViewport = page.getViewport({ scale: renderScale });
                    const aspectRatio = baseViewport.width / baseViewport.height;
                    const extraPadding = aspectRatio > 1 ? 250 : 0;
                    const marginPad = Math.max(120 + extraPadding, Math.round(Math.min(baseViewport.width, baseViewport.height) * 0.12));
                    const renderViewport = page.getViewport({ scale: renderScale, offsetX: -marginPad, offsetY: -marginPad });
                    const pageCanvas = document.createElement('canvas');
                    pageCanvas.width = baseViewport.width + (marginPad * 2);
                    pageCanvas.height = baseViewport.height + (marginPad * 2);
                    const pageCtx = pageCanvas.getContext('2d');
                    pageCtx.translate(marginPad, marginPad);
                    await page.render({ canvasContext: pageCtx, viewport: renderViewport }).promise;
                    pageCtx.setTransform(1, 0, 0, 1, 0, 0);
                    const textBoxes = computeTextBoxesInRenderSpace(textContent, renderViewport).map(box => ({ x: box.x + marginPad, y: box.y + marginPad, w: box.w, h: box.h }));
                const initialCrops = [];
                // Raster images
                for (const paint of imagePaints) {
                    try {
                        let isMask = false;
                        if (!paint.inline && paint.arg) {
                            const obj = page.objs.get(paint.arg);
                            if (obj && obj.isMask) isMask = true;
                        }
                        if (isMask) continue;
                        const t1 = multiplyMatrices(viewport.transform, paint.ctm);
                        const p1 = applyToPoint(t1, 0, 0);
                        const p2 = applyToPoint(t1, 1, 0);
                        const p3 = applyToPoint(t1, 0, 1);
                        const p4 = applyToPoint(t1, 1, 1);
                        const minX1 = Math.min(p1.x, p2.x, p3.x, p4.x);
                        const minY1 = Math.min(p1.y, p2.y, p3.y, p4.y);
                        const maxX1 = Math.max(p1.x, p2.x, p3.x, p4.x);
                        const maxY1 = Math.max(p1.y, p2.y, p3.y, p4.y);
                        const dispWidth1 = Math.max(0, maxX1 - minX1);
                        const dispHeight1 = Math.max(0, maxY1 - minY1);
                        if (dispWidth1 * dispHeight1 < minPixelArea) continue;
                        const ar = dispWidth1 / Math.max(1, dispHeight1);
                        if (skipTables && (ar > 4 || ar < 0.25)) continue; // skip likely tables
                const tr = multiplyMatrices(renderViewport.transform, paint.ctm);
                const q1 = applyToPoint(tr, 0, 0);
                const q2 = applyToPoint(tr, 1, 0);
                const q3 = applyToPoint(tr, 0, 1);
                const q4 = applyToPoint(tr, 1, 1);
                let minX = Math.floor(Math.min(q1.x, q2.x, q3.x, q4.x));
                let minY = Math.floor(Math.min(q1.y, q2.y, q3.y, q4.y));
                let maxX = Math.ceil(Math.max(q1.x, q2.x, q3.x, q4.x));
                let maxY = Math.ceil(Math.max(q1.y, q2.y, q3.y, q4.y));
                // Adjust for margin padding used in render
                minX += marginPad; minY += marginPad; maxX += marginPad; maxY += marginPad;
                // Clamp to expanded canvas bounds
                minX = Math.max(0, minX); minY = Math.max(0, minY);
                maxX = Math.min(pageCanvas.width, maxX); maxY = Math.min(pageCanvas.height, maxY);
                let cropW = Math.max(1, maxX - minX);
                let cropH = Math.max(1, maxY - minY);
                if (cropW <= 1 || cropH <= 1) continue;
                const inset = 0;
                minX += inset; minY += inset; cropW -= inset * 2; cropH -= inset * 2;
                if (cropW <= 1 || cropH <= 1) continue;
                // Defer trimming until after merging (match ExtractFigures)
                initialCrops.push({ x: minX, y: minY, w: cropW, h: cropH });
                    } catch {}
                }
                // Vector figures (Form XObjects)
                for (const form of formPaints) {
                    try {
                        const [bx1, by1, bx2, by2] = form.bbox;
                        const t1 = multiplyMatrices(viewport.transform, form.ctm);
                        const v1 = applyToPoint(t1, bx1, by1);
                        const v2 = applyToPoint(t1, bx2, by1);
                        const v3 = applyToPoint(t1, bx1, by2);
                        const v4 = applyToPoint(t1, bx2, by2);
                        const minX1 = Math.min(v1.x, v2.x, v3.x, v4.x);
                        const minY1 = Math.min(v1.y, v2.y, v3.y, v4.y);
                        const maxX1 = Math.max(v1.x, v2.x, v3.x, v4.x);
                        const maxY1 = Math.max(v1.y, v2.y, v3.y, v4.y);
                        const dispWidth1 = Math.max(0, maxX1 - minX1);
                        const dispHeight1 = Math.max(0, maxY1 - minY1);
                        if (dispWidth1 * dispHeight1 < minPixelArea) continue;
                        // Compute crop in render space
                        const tr = multiplyMatrices(renderViewport.transform, form.ctm);
                        const q1 = applyToPoint(tr, bx1, by1);
                        const q2 = applyToPoint(tr, bx2, by1);
                        const q3 = applyToPoint(tr, bx1, by2);
                        const q4 = applyToPoint(tr, bx2, by2);
                        let minX = Math.floor(Math.min(q1.x, q2.x, q3.x, q4.x));
                        let minY = Math.floor(Math.min(q1.y, q2.y, q3.y, q4.y));
                        let maxX = Math.ceil(Math.max(q1.x, q2.x, q3.x, q4.x));
                        let maxY = Math.ceil(Math.max(q1.y, q2.y, q3.y, q4.y));
                        minX += marginPad; minY += marginPad; maxX += marginPad; maxY += marginPad;
                        minX = Math.max(0, minX); minY = Math.max(0, minY);
                        maxX = Math.min(pageCanvas.width, maxX); maxY = Math.min(pageCanvas.height, maxY);
                        let cropW = Math.max(1, maxX - minX);
                        let cropH = Math.max(1, maxY - minY);
                        if (cropW <= 1 || cropH <= 1) continue;
                        initialCrops.push({ x: minX, y: minY, w: cropW, h: cropH });
                    } catch {}
                }
                    if (initialCrops.length === 0) continue;
                const mergedCrops = mergeImageBoxes(initialCrops, textBoxes);
                for (const crop of mergedCrops) {
                    let { x: cx, y: cy, w: cw, h: ch } = crop;
                    if (cw <= 1 || ch <= 1) continue;
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = cw; tempCanvas.height = ch;
                    tempCanvas.getContext('2d').drawImage(pageCanvas, cx, cy, cw, ch, 0, 0, cw, ch);
                    const MAX_DIM = 1024;
                    const scale = Math.min(MAX_DIM / cw, MAX_DIM / ch, 1);
                    const newWidth = Math.round(cw * scale);
                    const newHeight = Math.round(ch * scale);
                    const finalCanvas = document.createElement('canvas');
                    finalCanvas.width = newWidth; finalCanvas.height = newHeight;
                    finalCanvas.getContext('2d').drawImage(tempCanvas, 0, 0, newWidth, newHeight);
                    const blob = await new Promise(resolve => finalCanvas.toBlob(resolve, 'image/png'));
                    if (!blob) continue;
                    const { title, caption } = (typeof extractCaption === 'function') ? extractCaption(textContent.items) : { title: '', caption: '' };
                    extractedFigures.push({
                        page: pageNum, width: newWidth, height: newHeight, blob, url: URL.createObjectURL(blob),
                        bbox: { x: cx, y: cy, w: cw, h: ch },
                        filename: suggestFilename(title, pageNum), title, caption, selected: true
                    });
                }
                }
                updateFxProgress(100);
                attachFxListeners();
                displayFxResults();
            } catch (err) {
                fxError(`Error processing PDF file: ${err.message}`);
            } finally {
                setTimeout(()=> fx.progress.style.display='none', 500);
            }
        }

        // Vector figures via Form XObjects are now captured too

        // --------------------------------------------------------------- 
        // CONVERSION PROMPT
        // ---------------------------------------------------------------
const CONVERSION_PROMPT = `Convert an academic research paper (from PDF or LaTeX source) into a structured XML document with the following rules. Transcribe the raw text of the paper EXACTLY, without correcting spelling and grammar, with the sole exception that you do not need to maintain line breaks (and hyphenations from line breaks) and other "pure formatting" aspects of the pdf. You do NOT need to transcribe a bibliography or works cited section, since you will be noting citations inline as they appear, or the 'thank you' notes if any on the first page. You DO need to transcribe the content of appendices. Export ONLY the xml, wrapped in <PAPER> </PAPER>. Place tables, figures, equations in the order they appear in the text, at the nearest paragraph break to where they appear in the paper.

XML Structure Rules

Metadata:

Wrap the title in <TITLE>...</TITLE>.

Wrap the author list in <AUTHORS>...</AUTHORS>. The author list should just be a comma-delimited set of names; no affiliations, emails, icon pointers or similar should be transcribed.

Use <PUBLICATION_DATE>YYYY-MM-DD</PUBLICATION_DATE> if date is available.

Use <ABSTRACT>...</ABSTRACT> if there is an abstract. Only include this if you are sure a given chunk of text is actually the abstract.

Use <PLAINTEXT>...</PLAINTEXT> ALWAYS to give a VERY ACCURATE but New Yorker style interpretation of the most important results of the paper. It should be in the format: 1) What is the main question? 2) How do we answer it? 3) What do we find? 4) Why should we care? If the paper is particularly technical, consider this a Quanta magazine rather than a New Yorker magazine style of interpretation. Do NOT state those four questions - just write in a way that answers them. DO NOT say things 'the paper states' and 'the authors construct' - write it like John Brooks or John McPhee was describing the paper as clearly as possible, that a layman would understand (or if a very technical paper, that someone in the field who isn't is a specialist would understand). This should be 200-300 words, GOOD WRITING, and very interesting.

Headings:

Use <SECTION ref="sec_id">Section Title</SECTION> at the start of top-level sections.

Use <SUBSECTION ref="subsec_id">Subsection Title</SUBSECTION> at the start of subsections.

Use <SUBSUBSECTION ref="subsubsec_id">Subsubsection Title</SUBSUBSECTION> for sub-subsections.

Text:

Leave plain text unwrapped.  Lists, italics, etc. should be be converted to <li> <i> etc. with proper closure.

Use paragraph breaks (\\n\\n) between paragraphs. Do not wrap in <P> or any block tag.

Mathematics:

ALWAYS wrap inline math in <MATH>...</MATH>. All math within this should be written in TeX. ALWAYS use \\lt, \\leq, \\gt, \\geq for greater than or less than because otherwise it will break the XML rendering. Be sure to always write mathematics EXACTLY in latex format.

Wrap display/full-line equations in <FULL_LINE_EQUATION ref="eq_id"> <MATH>...</MATH> </FULL_LINE_EQUATION>. Again, this should be written in TeX.

Formal Content:

Use semantic tags with ref attributes. These should began with EXAMPLE 3 or PROPOSITION 1 or similar if they are numbered in the text.

<THEOREM ref="thm_id">...</THEOREM>

<PROPOSITION ref="prop_id">...</PROPOSITION>

<COROLLARY ref="cor_id">...</COROLLARY>

<PROOF ref="proof_id">...</PROOF>

<LEMMA ref="lemma_id">...</LEMMA>

<DEFINITION ref="def_id">...</DEFINITION>

<ASSUMPTION ref="assm_id">...</ASSUMPTION>

<EXAMPLE ref="ex_id">...</EXAMPLE>

Citations & Footnotes:

<CITATION ref="cite_id" title="The Title of the Paper" authors="Author 1, Author 2, and Author 3" year="year" journal="Journal Name">Bryan et al. (2019)</CITATION>

The internal part of this tag should be exactly what the inline citation appears in the paper as, e.g., (Bryan et al 1994), [Johnson 1987], Smith and Jones 1974, [3], etc. Always include the full paper title, authors, year (if available), journal name.

Use <FOOTNOTE ref="fn_id">...</FOOTNOTE>

Do NOT include the superscript for a footnote when you are transcribing the document; instead, just give me the footnote text wrapped in this tag. Do NOT include <CITATION> or other tags within footnote; just give me the footnote text (even if is to a citation). You may include math within a footnote.

Tables:
<TABLE ref="tbl_id">
  <thead>
    <tr><th>Header1</th><th>Header2</th></tr>
  </thead>
  <tbody>
    <tr><td>Row1Col1</td><td>Row1Col2</td></tr>
  </tbody>
</TABLE>

Figures:

<FIGURE ref="fig_id">
  <CAPTION>Figure caption</CAPTION>
  <IMG src="fig_id.png">
</FIGURE>

Figures should always be named fig_1.png, fig_2.png, etc., in line with the original paper.

Appendices:

Wrap appendix content in <APPENDIX ref="appendix_id">...</APPENDIX>. Make sure to include the full text of the appendices, including tables.

Use standard HTML anchor format:

See <a href="#thm1">Theorem 1</a> or from <a href="#sec_model">Section 2</a>. Make sure that any reference to a theorem or table or similar that can be pointed to is pointed to.

Short Example Output
<TITLE>Optimal Taxation in Incomplete Markets</TITLE>
<AUTHORS>Jane Doe, John Smith</AUTHORS>
<PUBLICATION_DATE>2022-06-01</PUBLICATION_DATE>

We study optimal tax policy in incomplete markets with borrowing constraints.<FOOTNOTE ref="fn1">We thank seminar participants at MIT and Princeton.</FOOTNOTE> The problem is to figure out how consumers borrow, drawing on <CITATION ref="cite_1" title="Idiosyncratic Risk" authors="Aiyagari Rao" year="1994" journal="Quarterly Journal of Economics">Bryan et al. (2019)</CITATION> shows how precautionary savings affect wealth distribution.

<SECTION ref="sec_model">Model</SECTION>
Agents face idiosyncratic income risk and choose <MATH>c_t</MATH> and <MATH>a_{t+1}</MATH> to maximize utility:

<FULL_LINE_EQUATION ref="eq1">
  <MATH>u(c_t) + \\beta E_t[V(a_{t+1}, s_{t+1})]</MATH>
</FULL_LINE_EQUATION>

subject to a series of constraints.

<ASSUMPTION ref="assm1">ASSUMPTION 1: Markets are incomplete and there is no insurance against income shocks.</ASSUMPTION>

<THEOREM ref="thm1">THEOREM 1: The optimal tax rate is zero in steady state under conditions A–C.</THEOREM>
<PROOF ref="proof1">Follows from envelope conditions and Euler equation under the Ramsey planner's problem.</PROOF>

<TABLE ref="tbl1">
  <thead>
    <tr><th>Variable</th><th>Value</th></tr>
  </thead>
  <tbody>
    <tr><td><MATH>\\tau</MATH></td><td>0.15</td></tr>
  </tbody>
</TABLE>

So now what one can see in <a href="#fig1">Figure 1</a> is that, as noted in <a href="#sec_model">Section 1</a>, we have no need to consider further issues. 

<FIGURE ref="fig1">
  <CAPTION>Welfare across tax regimes</CAPTION>
  <IMG src="fig1_welfare.png" />
</FIGURE> shows how precautionary savings affect wealth distribution.`;

        // --------------------------------------------------------------- 
        // API KEY MANAGEMENT
        // ---------------------------------------------------------------

async function ensureLocalKey() {
  if (sessionApiKey) return sessionApiKey;

  // Only prompt on localhost/127.0.0.1
  const host = location.hostname;
  const isLocal = host === 'localhost' || host === '127.0.0.1';

  if (!isLocal) {
    throw new Error('Proxy required (no key exposed in production).');
  }

  return new Promise((resolve) => {
    apiKeyModal.classList.add('visible');
    const submit = () => {
      const key = apiKeyInput.value.trim();
      if (key) {
        sessionApiKey = key;
        apiKeyModal.classList.remove('visible');
        apiKeyInput.value = '';
        resolve(key);
      }
    };
    apiKeySubmit.onclick = submit;
    apiKeyInput.onkeypress = (e) => { if (e.key === 'Enter') submit(); };
  });
}

// ADD this helper near the top of your script:
async function postGemini(payload) {
  // 1) Try server-side proxy (keeps key private in production)
  try {
    const res = await fetch('gemini-proxy.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (res.ok) return await res.json();

    // If proxy returns non-JSON error, surface it
    const raw = await res.text();
    try { throw new Error(JSON.parse(raw).error || raw); } catch { throw new Error(raw); }
  } catch (err) {
    // 2) If we're local, fall back to direct Google call using a prompted key
    const host = location.hostname;
    const isLocal = host === 'localhost' || host === '127.0.0.1';
    if (!isLocal) throw err;

    const key = await ensureLocalKey();
    const model = payload.model || 'gemini-2.5-flash';
    const direct = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(model)}:generateContent?key=${encodeURIComponent(key)}`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ...payload, model: undefined }) // Google URL carries the model
      }
    );

    const raw = await direct.text();
    if (!direct.ok) {
      try { throw new Error(JSON.parse(raw).error?.message || raw); }
      catch { throw new Error(raw); }
    }
    try { return JSON.parse(raw); }
    catch { throw new Error('Non-JSON from Gemini:\n' + raw.slice(0, 300)); }
  }
}


        // --------------------------------------------------------------- 
        // PAPER TEXT EXTRACTION
        // ---------------------------------------------------------------
        function extractPaperText() {
            const xml = currentPaperXML;
            let text = '';
            
            const title = xml.querySelector('TITLE')?.textContent || '';
            document.getElementById('toc-title').textContent = title;
            const authors = xml.querySelector('AUTHORS')?.textContent || '';
            const abstract = xml.querySelector('ABSTRACT')?.textContent || '';
            
            text += `Title: ${title}\nAuthors: ${authors}\n`;
            if (abstract) text += `Abstract: ${abstract}\n\n`;
            
            const walker = document.createTreeWalker(
                xml.documentElement,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let node;
            while (node = walker.nextNode()) {
                const content = node.textContent.trim();
                if (content && !['TITLE', 'AUTHORS', 'ABSTRACT'].includes(node.parentNode.tagName)) {
                    text += content + ' ';
                }
            }
            
            currentPaperText = text;
        }

        // --------------------------------------------------------------- 
        // PAPER DATA LOADING
        // ---------------------------------------------------------------
        async function loadPaperData() {
            const params = new URLSearchParams(window.location.search);
            let dataUrl = params.get('data');

            // If a 'data' URL parameter exists, load the XML from there
            if (dataUrl) {
                try {
                    const response = await fetch(dataUrl);
                    if (!response.ok) throw new Error(`Failed to fetch paper data from ${dataUrl}`);
                    let xmlText = await response.text();
                    
                    // Clean up potential XML issues before parsing (allowlist sanitizer)
                    // Allow core XML tags plus safe inline/HTML formatting tags used in content
                    const allowedTags = new Set([
                      'PAPER','TITLE','AUTHORS','PUBLICATION_DATE','ABSTRACT','PLAINTEXT',
                      'SECTION','SUBSECTION','SUBSUBSECTION','FULL_LINE_EQUATION','MATH',
                      'THEOREM','PROPOSITION','COROLLARY','PROOF','LEMMA','DEFINITION','ASSUMPTION','EXAMPLE',
                      'FOOTNOTE','CITATION','TABLE','CAPTION','FIGURE','IMG','APPENDIX','XREF','PDF',
                      // Common inline/HTML tags that may appear in content
                      'B','I','EM','STRONG','UL','OL','LI','DL','DT','DD','A','BR','SUP','SUB',
                      // HTML table markup (in case model emits native HTML tables)
                      'THEAD','TBODY','TFOOT','TR','TH','TD'
                    ]);
                    function sanitizeXml(text) {
                      // 0) turn escaped allowed tags like &lt;a ...&gt; back into real tags
                      const unescapeAllowed = (t) => {
                        // self-closing first: &lt;TAG ... /&gt;
                        t = t.replace(/&lt;\s*([A-Za-z_][\w-]*)\b([\s\S]*?)\/&gt;/g, (m, n, attrs) => {
                          const name = n.toUpperCase();
                          if (!allowedTags.has(name)) return m; // leave escaped
                          const a = attrs.replace(/&amp;/g,'&').replace(/&quot;/g,'"').replace(/&apos;/g,"'").replace(/&lt;/g,'<').replace(/&gt;/g,'>');
                          return `<${n}${a}/>`;
                        });
                        // opening/closing: &lt;/TAG ...&gt; or &lt;TAG ...&gt;
                        t = t.replace(/&lt;(\/)?\s*([A-Za-z_][\w-]*)\b([\s\S]*?)&gt;/g, (m, slash, n, attrs) => {
                          const name = n.toUpperCase();
                          if (!allowedTags.has(name)) return m; // leave escaped
                          const a = attrs.replace(/&amp;/g,'&').replace(/&quot;/g,'"').replace(/&apos;/g,"'").replace(/&lt;/g,'<').replace(/&gt;/g,'>');
                          return `<${slash ? '/' : ''}${n}${a}>`;
                        });
                        return t;
                      };
                      text = unescapeAllowed(text);
                      // 1) escape stray ampersands
                      text = text.replace(/&(?!(?:amp|lt|gt|quot|apos|#\d+|#x[\da-fA-F]+);)/g, '&amp;');
                      // 2) keep only allowed tags; escape others and angle brackets in plain text
                      return text.replace(/(<[^>]+>)|([^<]+)/g, (match, tag, plain) => {
                        if (tag) {
                          const m = tag.match(/^<\/?\s*([A-Za-z_][\w-]*)/);
                          const name = m ? m[1].toUpperCase() : '';
                          if (!allowedTags.has(name)) return tag.replace(/</g,'&lt;').replace(/>/g,'&gt;');
                          return tag;
                        }
                        return plain.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                      });
                    }
                    xmlText = sanitizeXml(xmlText);

                    // Normalize and clean references in the XML so downloads are correct
                    function normalizeAndCleanXML(xmlStr) {
                      const parser = new DOMParser();
                      let doc = parser.parseFromString(xmlStr, 'application/xml');
                      // Build set of valid targets by @ref
                      const targetTags = [
                        'SECTION','SUBSECTION','SUBSUBSECTION','FIGURE','TABLE','FULL_LINE_EQUATION',
                        'THEOREM','PROPOSITION','COROLLARY','PROOF','LEMMA','DEFINITION','ASSUMPTION','EXAMPLE'
                      ];
                      const targets = new Set();
                      targetTags.forEach(tag => {
                        doc.querySelectorAll(tag).forEach(el => {
                          const id = el.getAttribute('ref');
                          if (id) targets.add(id);
                        });
                      });
                      const isInFootnote = (el) => {
                        let p = el.parentNode; const needle = 'FOOTNOTE';
                        while (p && p.nodeType === 1) { if (p.nodeName === needle) return true; p = p.parentNode; }
                        return false;
                      };
                      const unwrapKeepChildren = (el) => {
                        const parent = el.parentNode; if (!parent) return;
                        while (el.firstChild) parent.insertBefore(el.firstChild, el);
                        parent.removeChild(el);
                      };
                      // Remove/unwrap bad refs and all refs inside footnotes
                      doc.querySelectorAll('XREF').forEach(x => {
                        const ref = x.getAttribute('ref');
                        if (isInFootnote(x) || !ref || !targets.has(ref)) unwrapKeepChildren(x);
                      });
                      // Serialize back
                      const ser = new XMLSerializer().serializeToString(doc);
                      return { xmlText: ser, xmlDoc: doc };
                    }
                    const normalized = normalizeAndCleanXML(xmlText);
                    xmlText = normalized.xmlText;
                    
                    window.generatedXML = xmlText;
                    if (usedUploadThisSession) {
                        document.getElementById('downloadXmlBtn').style.display = 'block';
                    }

                    try {
                        currentPaperXML = normalized.xmlDoc || new DOMParser().parseFromString(xmlText, 'application/xml');
                        extractPaperText();
                        loadingOverlay.style.display = 'none';
                        renderPaperFromXML();
                        buildTOCFromXML();
                    } catch (e) {
                        loadingOverlay.style.display = 'none';
                        showXmlFallback(xmlText);
                    }
                } catch (error) {
                    console.error('Error loading paper data from URL:', error);
                    loadingOverlay.style.display = 'none';
                    showXmlFallback(window.generatedXML || '');
                }
                return;
            }

            // --- If no 'data' URL, handle the file upload and conversion process ---
            const uploadModal = document.getElementById('uploadModal');
            const fileInput = document.getElementById('fileInput');
            const convertBtn = document.getElementById('convertBtn');
            const uploadStatus = document.getElementById('uploadStatus');

            // Show the upload modal
            uploadModal.style.display = 'block';
            loadingOverlay.style.display = 'none';
            
            fileInput.addEventListener('change', async (e) => {
                const files = Array.from(e.target.files);
                if (files.length > 0) {
                    uploadStatus.innerHTML = `<strong>Selected:</strong> ${files.map(f => f.name).join(', ')}<br>Click "Convert Paper" to proceed.`;
                    convertBtn.style.display = 'block';
                    // Trigger figure extraction for PDF/PPTX
                    try {
                        const pdf = files.find(f => /\.pdf$/i.test(f.name));
                        const pptx = files.find(f => /\.pptx$/i.test(f.name));
                        if (pdf || pptx) {
                            fxOverlay.style.display = 'flex';
                            if (pdf) await handlePDFForFX(pdf); else await handlePPTXForFX(pptx);
                        } else {
                            resetFigureUI();
                            // No figures to review; kick off conversion automatically
                            const btn = document.getElementById('convertBtn');
                            if (btn && !btn.disabled) btn.click();
                        }
                    } catch (err) { console.error('Figure extraction error:', err); }
                } else {
                    uploadStatus.textContent = '';
                    convertBtn.style.display = 'none';
                    resetFigureUI();
                    fxOverlay.style.display = 'none';
                }
            });
            
            convertBtn.addEventListener('click', async () => {
                usedUploadThisSession = true;
                if (!fileInput.files.length) {
                    uploadStatus.textContent = 'Please select a file first.';
                    return;
                }

                // Update UI to show processing state
                uploadModal.style.display = 'none';
                loadingOverlay.style.display = 'flex'; // Show spinner
                convertBtn.disabled = true;

                // Helper function to read a file as a base64 string
                const fileToGenerativePart = async (file) => {
                    const base64EncodedDataPromise = new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result.split(',')[1]);
                        reader.readAsDataURL(file);
                    });
                    return {
                        inlineData: {
                            data: await base64EncodedDataPromise,
                            mimeType: file.type
                        },
                    };
                };

                try {
                    
                    // 2. Prepare the request for the Gemini API
                    const files = Array.from(fileInput.files);
                    const fileParts = await Promise.all(files.map(fileToGenerativePart));
                    // Prepare selected images (if any)
                    const selectedImages = extractedFigures.filter(f => f.selected);
                    // Map for local rendering of images by filename
                    window.figureBlobMap = Object.fromEntries(selectedImages.map(f => [f.filename, f.url]));
                    window.selectedExtractedFigures = selectedImages;
                    const toBase64 = (blob) => new Promise((resolve, reject) => { const r=new FileReader(); r.onloadend=()=>resolve(r.result.split(',')[1]); r.onerror=reject; r.readAsDataURL(blob); });
                    const imageParts = [];
                    for (const fig of selectedImages) {
                        const b64 = await toBase64(fig.blob);
                        imageParts.push({ text: `Image filename: ${fig.filename}` });
                        imageParts.push({ inlineData: { mimeType: 'image/png', data: b64 } });
                    }
                    const imagesInstruction = selectedImages.length ? `\n\nFigures: I am including figure image files. Use these exact filenames in <IMG src> where appropriate, and reference them in order of appearance in the text: ${selectedImages.map(f=>f.filename).join(', ')}.` : '';

const responseData = await postGemini({
  model: 'gemini-2.5-pro',
  contents: [{ parts: [{ text: CONVERSION_PROMPT + imagesInstruction }, ...fileParts, ...imageParts] }],
  generationConfig: { temperature: 0.1, maxOutputTokens: 65000 }
});
                    console.log('Received response from Gemini conversion');
                    
                    // 4. Extract and clean the XML from the response
                    let xmlText = responseData.candidates[0].content.parts[0].text;
                    // Remove markdown code block fences if the model adds them
                    xmlText = xmlText.trim().replace(/^```xml\n?/, '').replace(/\n?```$/, '');

                    // Sanitize before parsing using allowlist of tags
                    const allowedTags = new Set([
                      'PAPER','TITLE','AUTHORS','PUBLICATION_DATE','ABSTRACT','PLAINTEXT',
                      'SECTION','SUBSECTION','SUBSUBSECTION','FULL_LINE_EQUATION','MATH',
                      'THEOREM','PROPOSITION','COROLLARY','PROOF','LEMMA','DEFINITION','ASSUMPTION','EXAMPLE',
                      'FOOTNOTE','CITATION','TABLE','CAPTION','FIGURE','IMG','APPENDIX','XREF','PDF',
                      // Common inline/HTML tags that may appear in content
                      'B','I','EM','STRONG','UL','OL','LI','DL','DT','DD','A','BR','SUP','SUB',
                      // HTML table markup (in case model emits native HTML tables)
                      'THEAD','TBODY','TFOOT','TR','TH','TD'
                    ]);
                    function sanitizeXml(text) {
                      // 0) turn escaped allowed tags like &lt;a ...&gt; back into real tags
                      const unescapeAllowed = (t) => {
                        // self-closing first
                        t = t.replace(/&lt;\s*([A-Za-z_][\w-]*)\b([\s\S]*?)\/&gt;/g, (m, n, attrs) => {
                          const name = n.toUpperCase();
                          if (!allowedTags.has(name)) return m;
                          const a = attrs.replace(/&amp;/g,'&').replace(/&quot;/g,'"').replace(/&apos;/g,"'").replace(/&lt;/g,'<').replace(/&gt;/g,'>');
                          return `<${n}${a}/>`;
                        });
                        // opening/closing
                        t = t.replace(/&lt;(\/)?\s*([A-Za-z_][\w-]*)\b([\s\S]*?)&gt;/g, (m, slash, n, attrs) => {
                          const name = n.toUpperCase();
                          if (!allowedTags.has(name)) return m;
                          const a = attrs.replace(/&amp;/g,'&').replace(/&quot;/g,'"').replace(/&apos;/g,"'").replace(/&lt;/g,'<').replace(/&gt;/g,'>');
                          return `<${slash ? '/' : ''}${n}${a}>`;
                        });
                        return t;
                      };
                      text = unescapeAllowed(text);
                      // 1) escape stray ampersands
                      text = text.replace(/&(?!(?:amp|lt|gt|quot|apos|#\d+|#x[\da-fA-F]+);)/g, '&amp;');
                      // 2) escape angle brackets in non-tag text; only keep allowed tags
                      return text.replace(/(<[^>]+>)|([^<]+)/g, (match, tag, plain) => {
                        if (tag) {
                          const m = tag.match(/^<\/?\s*([A-Za-z_][\w-]*)/);
                          const name = m ? m[1].toUpperCase() : '';
                          if (!allowedTags.has(name)) {
                            // not an allowed tag: escape entire token
                            return tag.replace(/</g,'&lt;').replace(/>/g,'&gt;');
                          }
                          return tag; // keep allowed tag as-is
                        }
                        // escape < and > in plain text (fixes things like p<.00001)
                        return plain.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                      });
                    }
                    xmlText = sanitizeXml(xmlText);

                    // Normalize and clean references in the XML so downloads are correct
                    function normalizeAndCleanXML(xmlStr) {
                      const parser = new DOMParser();
                      let doc = parser.parseFromString(xmlStr, 'application/xml');
                      // Build set of valid targets by @ref
                      const targetTags = [
                        'SECTION','SUBSECTION','SUBSUBSECTION','FIGURE','TABLE','FULL_LINE_EQUATION',
                        'THEOREM','PROPOSITION','COROLLARY','PROOF','LEMMA','DEFINITION','ASSUMPTION','EXAMPLE'
                      ];
                      const targets = new Set();
                      targetTags.forEach(tag => {
                        doc.querySelectorAll(tag).forEach(el => {
                          const id = el.getAttribute('ref');
                          if (id) targets.add(id);
                        });
                      });
                      const isInFootnote = (el) => {
                        let p = el.parentNode; const needle = 'FOOTNOTE';
                        while (p && p.nodeType === 1) { if (p.nodeName === needle) return true; p = p.parentNode; }
                        return false;
                      };
                      const unwrapKeepChildren = (el) => {
                        const parent = el.parentNode; if (!parent) return;
                        while (el.firstChild) parent.insertBefore(el.firstChild, el);
                        parent.removeChild(el);
                      };
                      // Remove/unwrap bad refs and all refs inside footnotes
                      doc.querySelectorAll('XREF').forEach(x => {
                        const ref = x.getAttribute('ref');
                        if (isInFootnote(x) || !ref || !targets.has(ref)) unwrapKeepChildren(x);
                      });
                      // Serialize back
                      const ser = new XMLSerializer().serializeToString(doc);
                      return { xmlText: ser, xmlDoc: doc };
                    }
                    const normalized = normalizeAndCleanXML(xmlText);
                    xmlText = normalized.xmlText;

                    window.generatedXML = xmlText; // Store for potential download
                    if (usedUploadThisSession) {
                        document.getElementById('downloadXmlBtn').style.display = 'block';
                    }

                    // 5. Parse and render the generated XML
                    currentPaperXML = normalized.xmlDoc || new DOMParser().parseFromString(xmlText, "application/xml");
                    
                    extractPaperText();
                    renderPaperFromXML();
                    buildTOCFromXML();

                } catch (err) {
                    console.error('❌ Conversion failed:', err);
                    // still allow download + show raw if any XML was produced
                    showXmlFallback(window.generatedXML || '');
                } finally {
                    // 6. Reset UI
                    loadingOverlay.style.display = 'none';
                    convertBtn.disabled = false;
                }
            });
        }

        // --------------------------------------------------------------- 
        // XML CONTENT TRANSFORMATION HELPERS
        // ---------------------------------------------------------------
        function transformXMLContent(xmlStr) {
            /* 1. inline / display math ------------------------------------------ */
            xmlStr = xmlStr.replace(
                /<FULL_LINE_EQUATION[^>]*ref="([^"]+)"[^>]*>\s*(?:<MATH>([\s\S]*?)<\/MATH>|([\s\S]*?))\s*<\/FULL_LINE_EQUATION>/g,
                (_, eqId, innerWithTag, innerRaw) => {
                    const tex = (innerWithTag || innerRaw).trim();
                    return `<div class="equation-display" id="${eqId}">$$${tex}$$</div>`;
                }
            );

            xmlStr = xmlStr.replace(
                /<MATH>([\s\S]*?)<\/MATH>/g,
                (_, tex) => `\\(${tex}\\)`
            );

            // Preserve inline formatting and list tags (<b>, <i>, <em>, <strong>, <ul>, <ol>, <li>)

            /* 2. foot-notes (as popups, not a list) ----------------------------- */
            xmlStr = xmlStr.replace(/<FOOTNOTE[^>]*>([\s\S]*?)<\/FOOTNOTE>/g,
                (_, note) => {
                    footnoteCounter++;
                    // Remove CITATION tags and all their attributes, keep only inner text
                    let cleanNote = note.replace(/<CITATION[^>]*?>([\s\S]*?)<\/CITATION>/g, '$1');
                    const processedNote = cleanNote.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    return `<sup class="footnote-ref" data-footnote-content="${encodeURIComponent(processedNote)}">${footnoteCounter}</sup>`;
                });

            /* 3. citations ------------------------------------------------------- */
            xmlStr = xmlStr.replace(
                /<CITATION([^>]*)>([\s\S]*?)<\/CITATION>/g,
                (_, attrStr, visibleText) => {
                    const attrs = {};
                    attrStr.replace(/(\w+)="([^"]*)"/g, (_, key, val) => {
                        attrs[key.toLowerCase()] = val;
                    });

                    const popupHtml = `
                        <div class="citation-popup">
                            ${attrs.authors ? `<div class="citation-authors">${attrs.authors}</div>` : ''}
                            ${attrs.title ? `<div class="citation-title">${attrs.title}</div>` : ''}
                            ${(attrs.journal || attrs.year)
                                ? `<div class="citation-link">${[attrs.journal, attrs.year].filter(Boolean).join(', ')}</div>`
                                : ''}
                        </div>
                    `.trim();

                    return `<span class="citation" data-details="${encodeURIComponent(popupHtml)}">${visibleText}</span>`;
                }
            );

            // props
            xmlStr = xmlStr.replace(/<(THEOREM|PROOF|PROPOSITION|LEMMA|DEFINITION|ASSUMPTION|REMARK|COROLLARY|EXAMPLE)([^>]*)>([\s\S]*?)<\/\1>/g,
                (_, tagName, attrs, content) => {
                    const ref = attrs.match(/ref="([^"]+)"/)?.[1] || '';
                    const className = tagName.toLowerCase();
                    return `<div class="${className}" ${ref ? `id="${ref}"` : ''}>
                        ${content}
                    </div>`;
                });

            // figures
            xmlStr = xmlStr.replace(/<FIGURE([^>]*)>([\s\S]*?)<\/FIGURE>/gi,
                (_, attrs, content) => {
                    const ref = attrs.match(/ref="([^"]+)"/)?.[1] || '';
                    const cap = (content.match(/<CAPTION>([\s\S]*?)<\/CAPTION>/i)?.[1] || '').trim();
                    let img = content.match(/<IMG[^>]*src="([^"]+)"[^>]*\/?>/i)?.[1] || '';

                    // Map to locally extracted blobs if present
                    if (img && window.figureBlobMap && window.figureBlobMap[img]) {
                        img = window.figureBlobMap[img];
                    }
                    // Prepend base path from ?data= if needed
                    const dataParam = new URLSearchParams(window.location.search).get('data');
                    if (img && dataParam && !/^https?:\/\//i.test(img)) {
                        const basePath = dataParam.substring(0, dataParam.lastIndexOf('/') + 1);
                        img = basePath + img;
                    }

                    // Escape caption for attribute context
                    const capAttr = cap
                        .replace(/&/g, '&amp;')
                        .replace(/"/g, '&quot;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');

                    return `<div class="figure" ${ref ? `id="${ref}"` : ''}>
                        <img src="${img}" alt="${capAttr}">
                        ${cap ? `<div class="figure-caption">${cap}</div>` : ''}
                    </div>`;
                });

            // tables
            xmlStr = xmlStr.replace(/<TABLE([^>]*)>([\s\S]*?)<\/TABLE>/g,
                (_, attrs, content) => {
                    const ref = attrs.match(/ref="([^"]+)"/)?.[1] || '';
                    let caption = '';
                    content = content.replace(/<CAPTION>([\s\S]*?)<\/CAPTION>/gi, (_, cap) => {
                        caption = cap;
                        return '';
                    });
                    
                    // Convert XML/HTML table structure to HTML (normalize in case of uppercase)
                    let htmlTable = content
                        .replace(/<thead>/gi, '<thead>')
                        .replace(/<\/thead>/gi, '</thead>')
                        .replace(/<tbody>/gi, '<tbody>')
                        .replace(/<\/tbody>/gi, '</tbody>')
                        .replace(/<tfoot>/gi, '<tfoot>')
                        .replace(/<\/tfoot>/gi, '</tfoot>')
                        .replace(/<tr>/gi, '<tr>')
                        .replace(/<\/tr>/gi, '</tr>')
                        .replace(/<th>/gi, '<th>')
                        .replace(/<\/th>/gi, '</th>')
                        .replace(/<td>/gi, '<td>')
                        .replace(/<\/td>/gi, '</td>');
                    
                    return `<div class="table-container" ${ref ? `id="${ref}"` : ''}>
                        <table>${htmlTable}</table>
                        ${caption ? `<div class="table-caption">${caption}</div>` : ''}
                    </div>`;
                });

            // crossrefs
            xmlStr = xmlStr.replace(/<XREF[^>]*ref="([^"]+)"[^>]*>([\s\S]*?)<\/XREF>/g,
                (_, ref, text) => `<a href="#${ref}" class="xref">${text}</a>`);

            return xmlStr;
        }

        // --------------------------------------------------------------- 
        // XML PAPER RENDERING
        // ---------------------------------------------------------------
        function renderPaperFromXML() {
            const xml = currentPaperXML;
            // Reveal sidebar only once we have an XML to show
            const sb = document.getElementById('sidebar');
            if (sb) sb.style.display = 'block';

            // 1. Render the paper's header
            const title = xml.querySelector('TITLE').textContent;
            const authors = xml.querySelector('AUTHORS').textContent;
            const pubDate = xml.querySelector('PUBLICATION_DATE')?.textContent || '';
            const pdfUrl = xml.querySelector('PDF')?.textContent || '';

            let finalHtml = `
                <div class="paper-header">
                    <h1 class="paper-title">${title}</h1>
                    <div class="paper-authors">${authors}</div>
                    <div class="paper-metadata">
                        <span>${pubDate}</span>
                        ${pdfUrl ? `<a href="${pdfUrl}" style="text-decoration: none;" target="_blank">[PDF]</a>` : ''}
                    </div>
                </div>
            `;

            const plaintext = xml.querySelector('PLAINTEXT')?.textContent;
            if (plaintext) {
                window.plaintextContent = plaintext;
            }

            const abstract = xml.querySelector('ABSTRACT')?.textContent;
            if (abstract) {
                finalHtml += `
                    <div class="abstract">
                        <div class="abstract-label">Abstract</div>
                        ${abstract}
                    </div>
                `;
            }

            // 2. Set up parsing with paragraph buffer
            let paragraphBuffer = '';
            const INLINE_TAGS = ['CITATION', 'MATH', 'FOOTNOTE', 'XREF'];
            let sectionStack = [];

            function flushParagraphBuffer() {
                if (paragraphBuffer.trim()) {
                    finalHtml += `<p>${transformXMLContent(paragraphBuffer)}</p>`;
                }
                paragraphBuffer = '';
            }

            let currentNode = xml.querySelector('ABSTRACT')?.nextSibling || 
                          xml.querySelector('PLAINTEXT')?.nextSibling || 
                          (xml.querySelector('PUBLICATION_DATE') || xml.querySelector('AUTHORS')).nextSibling;

            while (currentNode) {
                if (currentNode.nodeType === 1 && 
                    (currentNode.tagName === 'PLAINTEXT' || currentNode.tagName === 'ABSTRACT')) {
                    currentNode = currentNode.nextSibling;
                    continue;
                }
                
                const isText = currentNode.nodeType === 3;
                const isInline = currentNode.nodeType === 1 && (
                    INLINE_TAGS.includes(currentNode.tagName) ||
                    (currentNode.tagName === 'a' && currentNode.getAttribute('href')?.startsWith('#'))
                );
                
                if (isText || isInline) {
                    const serialized = new XMLSerializer().serializeToString(currentNode);
                    // Break on blank lines
                    serialized.split(/\n\s*\n/).forEach((chunk, i, arr) => {
                        paragraphBuffer += chunk;
                        if (i < arr.length - 1) flushParagraphBuffer();
                    });
                } else if (currentNode.nodeType === 1) {
                    // First flush any buffered paragraph content
                    flushParagraphBuffer();
                    
                    const tagName = currentNode.tagName;
                    
                    if (tagName === 'SECTION' || tagName === 'SUBSECTION' || tagName === 'SUBSUBSECTION') {
                        // Close sections at same or lower level
                        while (sectionStack.length > 0 && 
                               getSectionLevel(sectionStack[sectionStack.length - 1]) >= getSectionLevel(tagName)) {
                            finalHtml += `</div></div>`;
                            sectionStack.pop();
                        }
                        
                        const secId = currentNode.getAttribute('ref') || `sec_${Date.now()}`;
                        const secTitle = currentNode.textContent.trim();
                        const level = getSectionLevel(tagName);
                        
                        finalHtml += `
                            <div id="${secId}" class="section section-level-${level}" data-section-id="${secId}">
                                <div class="section-header" data-section-id="${secId}">
                                    <span class="section-toggle">▼</span>
                                    <h${level + 1}>${secTitle}</h${level + 1}>
                                </div>
                                <div class="section-content" id="content-${secId}">
                        `;
                        
                        sectionStack.push(tagName);
                    } else {
                        // Handle other block elements without breaking them up
                        const blockContent = new XMLSerializer().serializeToString(currentNode);
                        finalHtml += transformXMLContent(blockContent);
                    }
                }
                currentNode = currentNode.nextSibling;
            }
            
            // Flush any remaining buffer and close sections
            flushParagraphBuffer();
            while (sectionStack.length > 0) {
                finalHtml += `</div></div>`;
                sectionStack.pop();
            }

            mainContent.innerHTML = finalHtml;
            attachSectionListeners();
            attachCitationListeners();
            attachFootnoteListeners();
            if (window.MathJax?.typesetPromise) MathJax.typesetPromise();
        }

        function getSectionLevel(tagName) {
            switch(tagName) {
                case 'SECTION': return 1;
                case 'SUBSECTION': return 2;
                case 'SUBSUBSECTION': return 3;
                default: return 0;
            }
        }

        // --------------------------------------------------------------- 
        // TABLE OF CONTENTS GENERATION
        // ---------------------------------------------------------------
        function buildTOCFromXML() {
            let tocHTML = '';
            // Correctly get the title from the SECTION tag's text content.
            currentPaperXML.querySelectorAll('SECTION').forEach(sec => {
                const id = sec.getAttribute('ref');
                const title = sec.textContent.trim(); // The only change needed for the TOC
                if (id && title) {
                    tocHTML += `
                        <li><a href="#" data-section-target="${id}">
                            ${title}
                        </a></li>
                    `;
                }
            });
            tocList.innerHTML = tocHTML;
            tocList.querySelectorAll('a').forEach(link => {
                link.addEventListener('click', e => {
                    e.preventDefault();
                    const target = document.querySelector(`[data-section-id="${e.target.dataset.sectionTarget}"]`);
                    target?.scrollIntoView({ behavior: 'smooth', block: 'start' });
                });
            });
        }

        // --------------------------------------------------------------- 
        // INTERACTIVE SECTION HANDLING
        // ---------------------------------------------------------------
        function attachSectionListeners() {
            document.querySelectorAll('.section-header').forEach(header => {
                header.addEventListener('click', () => {
                    const sectionId = header.dataset.sectionId;
                    const toggle = header.querySelector('.section-toggle');
                    const content = document.getElementById(`content-${sectionId}`);
                    
                    if (content.classList.contains('collapsed')) {
                        content.classList.remove('collapsed');
                        toggle.textContent = '▼';
                        expandedSections.add(sectionId);
                    } else {
                        content.classList.add('collapsed');
                        toggle.textContent = '▶';
                        expandedSections.delete(sectionId);
                    }
                });
            });
        }

        // --------------------------------------------------------------- 
        // CITATION AND FOOTNOTE INTERACTION
        // ---------------------------------------------------------------
        function attachCitationListeners() {
            document.querySelectorAll('.citation').forEach(cite => {
                const show = e => { showCitationPopup(cite); popup.dataset.sticky = 'true'; };
                const hide = () => { hidePopup(); popup.dataset.sticky = 'false'; };

                cite.addEventListener('click', e => { e.preventDefault(); show(); });
                cite.addEventListener('mouseenter', show);
                cite.addEventListener('mouseleave', hide);
            });
        }

        function attachFootnoteListeners() {
            document.querySelectorAll('.footnote-ref').forEach(ref => {
                const html = decodeURIComponent(ref.dataset.footnoteContent || '');
                const show = () => { showFootnotePopup(ref, html); popup.dataset.sticky = 'true'; };
                const hide = () => { hidePopup(); popup.dataset.sticky = 'false'; };

                ref.addEventListener('click', e => { e.preventDefault(); show(); });
                ref.addEventListener('mouseenter', show);
                ref.addEventListener('mouseleave', hide);
            });
        }

        // --------------------------------------------------------------- 
        // POPUP MANAGEMENT
        // ---------------------------------------------------------------
        function showCitationPopup(element) {
            const html = decodeURIComponent(element.dataset.details || '');
            popupContent.innerHTML = html;
            popup.classList.add('visible');
            positionPopup(popup, element.getBoundingClientRect());
        }

        function showFootnotePopup(element, html) {
            popupContent.innerHTML = html;
            popup.classList.add('visible');
            positionPopup(popup, element.getBoundingClientRect());
            if (window.MathJax?.typesetPromise) MathJax.typesetPromise([popupContent]);
        }

        function positionPopup(popup, targetRect) {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            // const viewportHeight = window.innerHeight;
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            popup.style.display = 'block'; // measure
            const popupRect = popup.getBoundingClientRect();

            let left = targetRect.left;

            // clamp so it can't overflow the viewport
            if (left + popupRect.width > vw - 8) left = vw - popupRect.width - 8;
            if (left < 8) left = 8;
            popup.style.left = left + 'px';

            // below by default; flip above if needed
            let top = targetRect.bottom + scrollTop + 5;
            if (top - scrollTop + popupRect.height > vh - 20) {
              top = targetRect.top + scrollTop - popupRect.height - 5;
            }
            popup.style.top = top + 'px';
            
            // Position horizontally centered on target
            // const left = targetRect.left;
            // popup.style.left = left + 'px';
            // popup.style.maxWidth = '400px';
            
            // Try positioning below the target first
            // let top = targetRect.bottom + scrollTop + 5;
            // popup.style.top = top + 'px';
            // popup.style.display = 'block'; // Temporarily show to get dimensions
            
            // Check if it goes off bottom of viewport
            // const popupRect = popup.getBoundingClientRect();
            // if (popupRect.bottom > viewportHeight - 20) {
                // Position above instead
         //       top = targetRect.top + scrollTop - popupRect.height - 5;
          //      popup.style.top = top + 'px';
          //  }
        }

        function hidePopup() {
            popup.classList.remove('visible');
            popup.style.display = 'none';
        }

        // --------------------------------------------------------------- 
        // PLAINTEXT SUMMARY MODAL
        // ---------------------------------------------------------------
        function showPlaintextModal() {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 8px; box-shadow: var(--popup-shadow); max-width: 700px; width: 90%; max-height: 80vh; overflow-y: auto; z-index: 2002;';
            
            // Process plaintext to preserve paragraphs and math
            let processedText = window.plaintextContent
                .split('\n\n')  // Split by double newlines for paragraphs
                .map(para => `<p style="margin-bottom: 1em; line-height: 1.7;">${para.trim()}</p>`)
                .join('');
            
            // Convert any LaTeX math (assuming $ or $ delimiters in plaintext)
            processedText = processedText.replace(/\$\$(.*?)\$\$/g, '$$$$1$$');
            processedText = processedText.replace(/\$(.*?)\$/g, '\\($1\\)');
            
            modal.innerHTML = `
                <div style="font-size: 1.1rem; line-height: 1.8; font-family: var(--font-serif);">
                    ${processedText}
                </div>
                <button onclick="this.parentElement.remove(); document.getElementById('modalOverlay').remove();" 
                        style="margin-top: 24px; padding: 10px 20px; background: #333; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1rem;">
                    Close
                </button>
            `;
            
            const overlay = document.createElement('div');
            overlay.id = 'modalOverlay';
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 2001;';
            overlay.onclick = () => { modal.remove(); overlay.remove(); };
            
            document.body.appendChild(overlay);
            document.body.appendChild(modal);
            
            // Render any math in the modal
            if (window.MathJax?.typesetPromise) {
                MathJax.typesetPromise([modal]);
            }
        }

        // --------------------------------------------------------------- 
        // ERROR HANDLING AND FALLBACKS
        // ---------------------------------------------------------------
        function showXmlFallback(xmlText) {
            // show download button if we have XML
            if (xmlText) {
                window.generatedXML = xmlText;
                const btn = document.getElementById('downloadXmlBtn');
                if (btn) btn.style.display = 'block';
            }
            // show as much as we can
            const escaped = (xmlText || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
            mainContent.innerHTML = `
                <div style="padding:24px;">
                    <strong>Rendered view had errors.</strong> You can still download the raw XML below. 
                    <pre style="white-space:pre-wrap;word-wrap:break-word;margin-top:12px;border:1px solid var(--border-color);padding:12px;max-height:50vh;overflow:auto;">${escaped}</pre>
                </div>`;
        }

        // --------------------------------------------------------------- 
        // AI CHAT FUNCTIONALITY
        // ---------------------------------------------------------------
        async function askAboutPaper(query, history = []) {
            if (!currentPaperText) extractPaperText();
            
            let conversationContext = '';
            if (history.length > 0) {
                conversationContext = '\n\nPrevious conversation:\n' + 
                    history.map(h => `${h.role}: ${h.content}`).join('\n') + '\n\n';
            }
            
            const prompt = `Based on the following academic paper, please answer this question: "${query}". The prior conversation context is: ${conversationContext}
            Paper: ${currentPaperText}
            
            Please provide a clear, concise answer based ONLY on the paper's content. If there is a single most relevant sentence from the paper that supports your answer (most cases), include it exactly as: <REFERENCE>One VERBATIM SENTENCE REPRODUCED EXACTLY from the paper.</REFERENCE>. Do NOT answer questions unrelated to the paper - just respond, I think that's unrelated to the paper, so I'm afraid I don't have an answer. Math should be written in LaTeX with $...$. Most answers will be a single paragraph; use up to 3 if absolutely necessary to answer the user question. Do not use Markdown in your response. Do NOT say 'based on the paper' or similar: the user knows this conversation is about a paper.`;

const data = await postGemini({
  model: 'gemini-2.5-flash',
  contents: [{ parts: [{ text: prompt }] }],
  generationConfig: { temperature: 0.3, maxOutputTokens: 8000 }
});
return data.candidates[0].content.parts[0].text;
        }

        async function sendMessage() {
            const query = chatInput.value.trim();
            if (!query) return;
            
            chatHistory.push({ role: 'User', content: query });
            chatMessages.innerHTML += `<div class="chat-message user">${query}</div>`;
            chatInput.value = '';
            chatMessages.innerHTML += `<div class="chat-message ai">Thinking...</div>`;
            
            try {
                let response = await askAboutPaper(query, chatHistory);
                
                response = response.replace(/(?<!\$)\$(\S(?:[^$]*?\S)?)\$(?!\$)/g, '\\($1\\)');
                
                // Check for reference
                const refMatch = response.match(/<REFERENCE>(.*?)<\/REFERENCE>/);
                if (refMatch) {
                    const refText = refMatch[1];
                    const pageText = document.body.innerText;
                    
                    if (pageText.includes(refText)) {
                        response = response.replace(/<REFERENCE>.*?<\/REFERENCE>/, 
                            `<span class="ref-link" onclick="highlightReference('${refText.replace(/'/g, "\\'")}')" style="cursor: pointer; color: var(--link-color); text-decoration: none; border-bottom: 1px dotted var(--link-color);">↗ View source</span>`);
                    } else {
                        response = response.replace(/<REFERENCE>.*?<\/REFERENCE>/, '');
                    }
                }
                
                chatHistory.push({ role: 'Assistant', content: response });
                chatMessages.lastElementChild.innerHTML = response;
                
                if (window.MathJax?.typesetPromise) {
                    MathJax.typesetPromise([chatMessages.lastElementChild]);
                }
            } catch (error) {
                chatMessages.lastElementChild.innerHTML = `Error: ${error.message}`;
            }
            
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function highlightReference(text) {
            chatOverlay.classList.remove('visible');
            
            const walker = document.createTreeWalker(
                mainContent,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let node;
            while (node = walker.nextNode()) {
                if (node.textContent.includes(text)) {
                    const parent = node.parentNode;
                    const textBefore = node.textContent.substring(0, node.textContent.indexOf(text));
                    const textAfter = node.textContent.substring(node.textContent.indexOf(text) + text.length);
                    
                    // Create highlighted span just for the sentence
                    const before = document.createTextNode(textBefore);
                    const highlighted = document.createElement('span');
                    highlighted.style.cssText = 'border-bottom: 3px solid yellow; transition: border-color 3s;';
                    highlighted.textContent = text;
                    const after = document.createTextNode(textAfter);
                    
                    parent.replaceChild(after, node);
                    parent.insertBefore(highlighted, after);
                    parent.insertBefore(before, highlighted);
                    
                    highlighted.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    setTimeout(() => {
                        highlighted.style.borderColor = 'transparent';
                    }, 3000);
                    break;
                }
            }
        }

        // --------------------------------------------------------------- 
        // EVENT LISTENERS SETUP
        // ---------------------------------------------------------------
        
        // Figure zoom interaction
        document.addEventListener('mousemove', e => {
            const fig = e.target.closest('.figure');
            if (fig && fig.querySelector('img')) {
                const img = fig.querySelector('img');
                const rect = fig.getBoundingClientRect();
                const x = ((e.clientX - rect.left) / rect.width) * 100;
                const y = ((e.clientY - rect.top) / rect.height) * 100;
                img.style.transformOrigin = `${x}% ${y}%`;
            }
        });

        // Chat functionality
        sendBtn.addEventListener('click', sendMessage);
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        // Global click handler for popups
        document.addEventListener('click', (e) => {
            // If popup is visible and click is not on popup or citation/footnote
            if (popup.classList.contains('visible')) {
                if (!popup.contains(e.target) && 
                    !e.target.classList.contains('citation') && 
                    !e.target.classList.contains('footnote-ref')) {
                    hidePopup();
                    popup.dataset.sticky = 'false';
                }
            }
        });

        // Chat modal controls
        talkButton.addEventListener('click', () => {
            chatOverlay.classList.add('visible');
        });

        const talkButtonMobile = document.getElementById('talkButtonMobile');
        if (talkButtonMobile) {
            talkButtonMobile.addEventListener('click', () => {
                chatOverlay.classList.add('visible');
            });
        }

        closeChat.addEventListener('click', () => {
            chatOverlay.classList.remove('visible');
        });

        chatOverlay.addEventListener('click', (e) => {
            if (e.target === chatOverlay) {
                chatOverlay.classList.remove('visible');
            }
        });

        // Download XML + images functionality (zip if images present)
        document.getElementById('downloadXmlBtn').addEventListener('click', async () => {
            if (!window.generatedXML) return;
            const selected = (window.selectedExtractedFigures || []).filter(f => f && f.blob);
            if (selected.length === 0 || typeof JSZip === 'undefined') {
                // Fallback: just XML
                const blob = new Blob([window.generatedXML], { type: 'text/xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = 'paper.xml'; a.click(); URL.revokeObjectURL(url);
                return;
            }
            const zip = new JSZip();
            zip.file('paper.xml', window.generatedXML);
            selected.forEach(fig => zip.file(fig.filename, fig.blob));
            const content = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(content);
            const a = document.createElement('a'); a.href = url; a.download = 'paper_with_images.zip'; a.click();
            URL.revokeObjectURL(url);
        });

        // Window resize handler
        window.addEventListener('resize', () => {
            if (popup.classList.contains('visible')) {
                hidePopup();
            }
        });

        // --------------------------------------------------------------- 
        // APPLICATION INITIALIZATION
        // ---------------------------------------------------------------
        document.addEventListener('DOMContentLoaded', () => {
            loadPaperData();
        });
    </script>
</body>
</html>
